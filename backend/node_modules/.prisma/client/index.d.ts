
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model authors
 * 
 */
export type authors = $Result.DefaultSelection<Prisma.$authorsPayload>
/**
 * Model entities
 * 
 */
export type entities = $Result.DefaultSelection<Prisma.$entitiesPayload>
/**
 * Model keywords
 * 
 */
export type keywords = $Result.DefaultSelection<Prisma.$keywordsPayload>
/**
 * Model mesh_terms
 * 
 */
export type mesh_terms = $Result.DefaultSelection<Prisma.$mesh_termsPayload>
/**
 * Model publication_authors
 * 
 */
export type publication_authors = $Result.DefaultSelection<Prisma.$publication_authorsPayload>
/**
 * Model publication_entities
 * 
 */
export type publication_entities = $Result.DefaultSelection<Prisma.$publication_entitiesPayload>
/**
 * Model publication_keywords
 * 
 */
export type publication_keywords = $Result.DefaultSelection<Prisma.$publication_keywordsPayload>
/**
 * Model publication_mesh_terms
 * 
 */
export type publication_mesh_terms = $Result.DefaultSelection<Prisma.$publication_mesh_termsPayload>
/**
 * Model publications
 * This model contains an expression index which requires additional setup for migrations. Visit https://pris.ly/d/expression-indexes for more info.
 */
export type publications = $Result.DefaultSelection<Prisma.$publicationsPayload>
/**
 * Model text_sections
 * 
 */
export type text_sections = $Result.DefaultSelection<Prisma.$text_sectionsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Authors
 * const authors = await prisma.authors.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Authors
   * const authors = await prisma.authors.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.authors`: Exposes CRUD operations for the **authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Authors
    * const authors = await prisma.authors.findMany()
    * ```
    */
  get authors(): Prisma.authorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entities`: Exposes CRUD operations for the **entities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Entities
    * const entities = await prisma.entities.findMany()
    * ```
    */
  get entities(): Prisma.entitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.keywords`: Exposes CRUD operations for the **keywords** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Keywords
    * const keywords = await prisma.keywords.findMany()
    * ```
    */
  get keywords(): Prisma.keywordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mesh_terms`: Exposes CRUD operations for the **mesh_terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mesh_terms
    * const mesh_terms = await prisma.mesh_terms.findMany()
    * ```
    */
  get mesh_terms(): Prisma.mesh_termsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publication_authors`: Exposes CRUD operations for the **publication_authors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publication_authors
    * const publication_authors = await prisma.publication_authors.findMany()
    * ```
    */
  get publication_authors(): Prisma.publication_authorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publication_entities`: Exposes CRUD operations for the **publication_entities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publication_entities
    * const publication_entities = await prisma.publication_entities.findMany()
    * ```
    */
  get publication_entities(): Prisma.publication_entitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publication_keywords`: Exposes CRUD operations for the **publication_keywords** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publication_keywords
    * const publication_keywords = await prisma.publication_keywords.findMany()
    * ```
    */
  get publication_keywords(): Prisma.publication_keywordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publication_mesh_terms`: Exposes CRUD operations for the **publication_mesh_terms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publication_mesh_terms
    * const publication_mesh_terms = await prisma.publication_mesh_terms.findMany()
    * ```
    */
  get publication_mesh_terms(): Prisma.publication_mesh_termsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.publications`: Exposes CRUD operations for the **publications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Publications
    * const publications = await prisma.publications.findMany()
    * ```
    */
  get publications(): Prisma.publicationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.text_sections`: Exposes CRUD operations for the **text_sections** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Text_sections
    * const text_sections = await prisma.text_sections.findMany()
    * ```
    */
  get text_sections(): Prisma.text_sectionsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.3
   * Query Engine version: bb420e667c1820a8c05a38023385f6cc7ef8e83a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    authors: 'authors',
    entities: 'entities',
    keywords: 'keywords',
    mesh_terms: 'mesh_terms',
    publication_authors: 'publication_authors',
    publication_entities: 'publication_entities',
    publication_keywords: 'publication_keywords',
    publication_mesh_terms: 'publication_mesh_terms',
    publications: 'publications',
    text_sections: 'text_sections'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "authors" | "entities" | "keywords" | "mesh_terms" | "publication_authors" | "publication_entities" | "publication_keywords" | "publication_mesh_terms" | "publications" | "text_sections"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      authors: {
        payload: Prisma.$authorsPayload<ExtArgs>
        fields: Prisma.authorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.authorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.authorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          findFirst: {
            args: Prisma.authorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.authorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          findMany: {
            args: Prisma.authorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>[]
          }
          create: {
            args: Prisma.authorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          createMany: {
            args: Prisma.authorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.authorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>[]
          }
          delete: {
            args: Prisma.authorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          update: {
            args: Prisma.authorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          deleteMany: {
            args: Prisma.authorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.authorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.authorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>[]
          }
          upsert: {
            args: Prisma.authorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$authorsPayload>
          }
          aggregate: {
            args: Prisma.AuthorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthors>
          }
          groupBy: {
            args: Prisma.authorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.authorsCountArgs<ExtArgs>
            result: $Utils.Optional<AuthorsCountAggregateOutputType> | number
          }
        }
      }
      entities: {
        payload: Prisma.$entitiesPayload<ExtArgs>
        fields: Prisma.entitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.entitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.entitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          findFirst: {
            args: Prisma.entitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.entitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          findMany: {
            args: Prisma.entitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>[]
          }
          create: {
            args: Prisma.entitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          createMany: {
            args: Prisma.entitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.entitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>[]
          }
          delete: {
            args: Prisma.entitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          update: {
            args: Prisma.entitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          deleteMany: {
            args: Prisma.entitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.entitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.entitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>[]
          }
          upsert: {
            args: Prisma.entitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$entitiesPayload>
          }
          aggregate: {
            args: Prisma.EntitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntities>
          }
          groupBy: {
            args: Prisma.entitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.entitiesCountArgs<ExtArgs>
            result: $Utils.Optional<EntitiesCountAggregateOutputType> | number
          }
        }
      }
      keywords: {
        payload: Prisma.$keywordsPayload<ExtArgs>
        fields: Prisma.keywordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.keywordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.keywordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          findFirst: {
            args: Prisma.keywordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.keywordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          findMany: {
            args: Prisma.keywordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>[]
          }
          create: {
            args: Prisma.keywordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          createMany: {
            args: Prisma.keywordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.keywordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>[]
          }
          delete: {
            args: Prisma.keywordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          update: {
            args: Prisma.keywordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          deleteMany: {
            args: Prisma.keywordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.keywordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.keywordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>[]
          }
          upsert: {
            args: Prisma.keywordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$keywordsPayload>
          }
          aggregate: {
            args: Prisma.KeywordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKeywords>
          }
          groupBy: {
            args: Prisma.keywordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<KeywordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.keywordsCountArgs<ExtArgs>
            result: $Utils.Optional<KeywordsCountAggregateOutputType> | number
          }
        }
      }
      mesh_terms: {
        payload: Prisma.$mesh_termsPayload<ExtArgs>
        fields: Prisma.mesh_termsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.mesh_termsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.mesh_termsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>
          }
          findFirst: {
            args: Prisma.mesh_termsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.mesh_termsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>
          }
          findMany: {
            args: Prisma.mesh_termsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>[]
          }
          create: {
            args: Prisma.mesh_termsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>
          }
          createMany: {
            args: Prisma.mesh_termsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.mesh_termsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>[]
          }
          delete: {
            args: Prisma.mesh_termsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>
          }
          update: {
            args: Prisma.mesh_termsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>
          }
          deleteMany: {
            args: Prisma.mesh_termsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.mesh_termsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.mesh_termsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>[]
          }
          upsert: {
            args: Prisma.mesh_termsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$mesh_termsPayload>
          }
          aggregate: {
            args: Prisma.Mesh_termsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMesh_terms>
          }
          groupBy: {
            args: Prisma.mesh_termsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Mesh_termsGroupByOutputType>[]
          }
          count: {
            args: Prisma.mesh_termsCountArgs<ExtArgs>
            result: $Utils.Optional<Mesh_termsCountAggregateOutputType> | number
          }
        }
      }
      publication_authors: {
        payload: Prisma.$publication_authorsPayload<ExtArgs>
        fields: Prisma.publication_authorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publication_authorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publication_authorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>
          }
          findFirst: {
            args: Prisma.publication_authorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publication_authorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>
          }
          findMany: {
            args: Prisma.publication_authorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>[]
          }
          create: {
            args: Prisma.publication_authorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>
          }
          createMany: {
            args: Prisma.publication_authorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publication_authorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>[]
          }
          delete: {
            args: Prisma.publication_authorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>
          }
          update: {
            args: Prisma.publication_authorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>
          }
          deleteMany: {
            args: Prisma.publication_authorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publication_authorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publication_authorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>[]
          }
          upsert: {
            args: Prisma.publication_authorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_authorsPayload>
          }
          aggregate: {
            args: Prisma.Publication_authorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication_authors>
          }
          groupBy: {
            args: Prisma.publication_authorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Publication_authorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.publication_authorsCountArgs<ExtArgs>
            result: $Utils.Optional<Publication_authorsCountAggregateOutputType> | number
          }
        }
      }
      publication_entities: {
        payload: Prisma.$publication_entitiesPayload<ExtArgs>
        fields: Prisma.publication_entitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publication_entitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publication_entitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>
          }
          findFirst: {
            args: Prisma.publication_entitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publication_entitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>
          }
          findMany: {
            args: Prisma.publication_entitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>[]
          }
          create: {
            args: Prisma.publication_entitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>
          }
          createMany: {
            args: Prisma.publication_entitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publication_entitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>[]
          }
          delete: {
            args: Prisma.publication_entitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>
          }
          update: {
            args: Prisma.publication_entitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>
          }
          deleteMany: {
            args: Prisma.publication_entitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publication_entitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publication_entitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>[]
          }
          upsert: {
            args: Prisma.publication_entitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_entitiesPayload>
          }
          aggregate: {
            args: Prisma.Publication_entitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication_entities>
          }
          groupBy: {
            args: Prisma.publication_entitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Publication_entitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.publication_entitiesCountArgs<ExtArgs>
            result: $Utils.Optional<Publication_entitiesCountAggregateOutputType> | number
          }
        }
      }
      publication_keywords: {
        payload: Prisma.$publication_keywordsPayload<ExtArgs>
        fields: Prisma.publication_keywordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publication_keywordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publication_keywordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>
          }
          findFirst: {
            args: Prisma.publication_keywordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publication_keywordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>
          }
          findMany: {
            args: Prisma.publication_keywordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>[]
          }
          create: {
            args: Prisma.publication_keywordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>
          }
          createMany: {
            args: Prisma.publication_keywordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publication_keywordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>[]
          }
          delete: {
            args: Prisma.publication_keywordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>
          }
          update: {
            args: Prisma.publication_keywordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>
          }
          deleteMany: {
            args: Prisma.publication_keywordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publication_keywordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publication_keywordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>[]
          }
          upsert: {
            args: Prisma.publication_keywordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_keywordsPayload>
          }
          aggregate: {
            args: Prisma.Publication_keywordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication_keywords>
          }
          groupBy: {
            args: Prisma.publication_keywordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Publication_keywordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.publication_keywordsCountArgs<ExtArgs>
            result: $Utils.Optional<Publication_keywordsCountAggregateOutputType> | number
          }
        }
      }
      publication_mesh_terms: {
        payload: Prisma.$publication_mesh_termsPayload<ExtArgs>
        fields: Prisma.publication_mesh_termsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publication_mesh_termsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publication_mesh_termsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>
          }
          findFirst: {
            args: Prisma.publication_mesh_termsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publication_mesh_termsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>
          }
          findMany: {
            args: Prisma.publication_mesh_termsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>[]
          }
          create: {
            args: Prisma.publication_mesh_termsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>
          }
          createMany: {
            args: Prisma.publication_mesh_termsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publication_mesh_termsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>[]
          }
          delete: {
            args: Prisma.publication_mesh_termsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>
          }
          update: {
            args: Prisma.publication_mesh_termsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>
          }
          deleteMany: {
            args: Prisma.publication_mesh_termsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publication_mesh_termsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publication_mesh_termsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>[]
          }
          upsert: {
            args: Prisma.publication_mesh_termsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publication_mesh_termsPayload>
          }
          aggregate: {
            args: Prisma.Publication_mesh_termsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublication_mesh_terms>
          }
          groupBy: {
            args: Prisma.publication_mesh_termsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Publication_mesh_termsGroupByOutputType>[]
          }
          count: {
            args: Prisma.publication_mesh_termsCountArgs<ExtArgs>
            result: $Utils.Optional<Publication_mesh_termsCountAggregateOutputType> | number
          }
        }
      }
      publications: {
        payload: Prisma.$publicationsPayload<ExtArgs>
        fields: Prisma.publicationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.publicationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.publicationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          findFirst: {
            args: Prisma.publicationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.publicationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          findMany: {
            args: Prisma.publicationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>[]
          }
          create: {
            args: Prisma.publicationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          createMany: {
            args: Prisma.publicationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.publicationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>[]
          }
          delete: {
            args: Prisma.publicationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          update: {
            args: Prisma.publicationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          deleteMany: {
            args: Prisma.publicationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.publicationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.publicationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>[]
          }
          upsert: {
            args: Prisma.publicationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$publicationsPayload>
          }
          aggregate: {
            args: Prisma.PublicationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePublications>
          }
          groupBy: {
            args: Prisma.publicationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PublicationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.publicationsCountArgs<ExtArgs>
            result: $Utils.Optional<PublicationsCountAggregateOutputType> | number
          }
        }
      }
      text_sections: {
        payload: Prisma.$text_sectionsPayload<ExtArgs>
        fields: Prisma.text_sectionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.text_sectionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.text_sectionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>
          }
          findFirst: {
            args: Prisma.text_sectionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.text_sectionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>
          }
          findMany: {
            args: Prisma.text_sectionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>[]
          }
          create: {
            args: Prisma.text_sectionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>
          }
          createMany: {
            args: Prisma.text_sectionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.text_sectionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>[]
          }
          delete: {
            args: Prisma.text_sectionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>
          }
          update: {
            args: Prisma.text_sectionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>
          }
          deleteMany: {
            args: Prisma.text_sectionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.text_sectionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.text_sectionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>[]
          }
          upsert: {
            args: Prisma.text_sectionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$text_sectionsPayload>
          }
          aggregate: {
            args: Prisma.Text_sectionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateText_sections>
          }
          groupBy: {
            args: Prisma.text_sectionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Text_sectionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.text_sectionsCountArgs<ExtArgs>
            result: $Utils.Optional<Text_sectionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    authors?: authorsOmit
    entities?: entitiesOmit
    keywords?: keywordsOmit
    mesh_terms?: mesh_termsOmit
    publication_authors?: publication_authorsOmit
    publication_entities?: publication_entitiesOmit
    publication_keywords?: publication_keywordsOmit
    publication_mesh_terms?: publication_mesh_termsOmit
    publications?: publicationsOmit
    text_sections?: text_sectionsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AuthorsCountOutputType
   */

  export type AuthorsCountOutputType = {
    publication_authors: number
  }

  export type AuthorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_authors?: boolean | AuthorsCountOutputTypeCountPublication_authorsArgs
  }

  // Custom InputTypes
  /**
   * AuthorsCountOutputType without action
   */
  export type AuthorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthorsCountOutputType
     */
    select?: AuthorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AuthorsCountOutputType without action
   */
  export type AuthorsCountOutputTypeCountPublication_authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_authorsWhereInput
  }


  /**
   * Count Type EntitiesCountOutputType
   */

  export type EntitiesCountOutputType = {
    publication_entities: number
  }

  export type EntitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_entities?: boolean | EntitiesCountOutputTypeCountPublication_entitiesArgs
  }

  // Custom InputTypes
  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntitiesCountOutputType
     */
    select?: EntitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntitiesCountOutputType without action
   */
  export type EntitiesCountOutputTypeCountPublication_entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_entitiesWhereInput
  }


  /**
   * Count Type KeywordsCountOutputType
   */

  export type KeywordsCountOutputType = {
    publication_keywords: number
  }

  export type KeywordsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_keywords?: boolean | KeywordsCountOutputTypeCountPublication_keywordsArgs
  }

  // Custom InputTypes
  /**
   * KeywordsCountOutputType without action
   */
  export type KeywordsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KeywordsCountOutputType
     */
    select?: KeywordsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KeywordsCountOutputType without action
   */
  export type KeywordsCountOutputTypeCountPublication_keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_keywordsWhereInput
  }


  /**
   * Count Type Mesh_termsCountOutputType
   */

  export type Mesh_termsCountOutputType = {
    publication_mesh_terms: number
  }

  export type Mesh_termsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_mesh_terms?: boolean | Mesh_termsCountOutputTypeCountPublication_mesh_termsArgs
  }

  // Custom InputTypes
  /**
   * Mesh_termsCountOutputType without action
   */
  export type Mesh_termsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mesh_termsCountOutputType
     */
    select?: Mesh_termsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Mesh_termsCountOutputType without action
   */
  export type Mesh_termsCountOutputTypeCountPublication_mesh_termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_mesh_termsWhereInput
  }


  /**
   * Count Type PublicationsCountOutputType
   */

  export type PublicationsCountOutputType = {
    publication_authors: number
    publication_entities: number
    publication_keywords: number
    publication_mesh_terms: number
    text_sections: number
  }

  export type PublicationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_authors?: boolean | PublicationsCountOutputTypeCountPublication_authorsArgs
    publication_entities?: boolean | PublicationsCountOutputTypeCountPublication_entitiesArgs
    publication_keywords?: boolean | PublicationsCountOutputTypeCountPublication_keywordsArgs
    publication_mesh_terms?: boolean | PublicationsCountOutputTypeCountPublication_mesh_termsArgs
    text_sections?: boolean | PublicationsCountOutputTypeCountText_sectionsArgs
  }

  // Custom InputTypes
  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PublicationsCountOutputType
     */
    select?: PublicationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeCountPublication_authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_authorsWhereInput
  }

  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeCountPublication_entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_entitiesWhereInput
  }

  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeCountPublication_keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_keywordsWhereInput
  }

  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeCountPublication_mesh_termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_mesh_termsWhereInput
  }

  /**
   * PublicationsCountOutputType without action
   */
  export type PublicationsCountOutputTypeCountText_sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: text_sectionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model authors
   */

  export type AggregateAuthors = {
    _count: AuthorsCountAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  export type AuthorsMinAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    orcid: string | null
    created_at: Date | null
  }

  export type AuthorsMaxAggregateOutputType = {
    id: string | null
    firstname: string | null
    lastname: string | null
    email: string | null
    orcid: string | null
    created_at: Date | null
  }

  export type AuthorsCountAggregateOutputType = {
    id: number
    firstname: number
    lastname: number
    email: number
    orcid: number
    created_at: number
    _all: number
  }


  export type AuthorsMinAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    orcid?: true
    created_at?: true
  }

  export type AuthorsMaxAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    orcid?: true
    created_at?: true
  }

  export type AuthorsCountAggregateInputType = {
    id?: true
    firstname?: true
    lastname?: true
    email?: true
    orcid?: true
    created_at?: true
    _all?: true
  }

  export type AuthorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authors to aggregate.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned authors
    **/
    _count?: true | AuthorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthorsMaxAggregateInputType
  }

  export type GetAuthorsAggregateType<T extends AuthorsAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthors[P]>
      : GetScalarType<T[P], AggregateAuthors[P]>
  }




  export type authorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: authorsWhereInput
    orderBy?: authorsOrderByWithAggregationInput | authorsOrderByWithAggregationInput[]
    by: AuthorsScalarFieldEnum[] | AuthorsScalarFieldEnum
    having?: authorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthorsCountAggregateInputType | true
    _min?: AuthorsMinAggregateInputType
    _max?: AuthorsMaxAggregateInputType
  }

  export type AuthorsGroupByOutputType = {
    id: string
    firstname: string | null
    lastname: string
    email: string | null
    orcid: string | null
    created_at: Date
    _count: AuthorsCountAggregateOutputType | null
    _min: AuthorsMinAggregateOutputType | null
    _max: AuthorsMaxAggregateOutputType | null
  }

  type GetAuthorsGroupByPayload<T extends authorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
            : GetScalarType<T[P], AuthorsGroupByOutputType[P]>
        }
      >
    >


  export type authorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    orcid?: boolean
    created_at?: boolean
    publication_authors?: boolean | authors$publication_authorsArgs<ExtArgs>
    _count?: boolean | AuthorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authors"]>

  export type authorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    orcid?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["authors"]>

  export type authorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    orcid?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["authors"]>

  export type authorsSelectScalar = {
    id?: boolean
    firstname?: boolean
    lastname?: boolean
    email?: boolean
    orcid?: boolean
    created_at?: boolean
  }

  export type authorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "firstname" | "lastname" | "email" | "orcid" | "created_at", ExtArgs["result"]["authors"]>
  export type authorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_authors?: boolean | authors$publication_authorsArgs<ExtArgs>
    _count?: boolean | AuthorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type authorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type authorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $authorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "authors"
    objects: {
      publication_authors: Prisma.$publication_authorsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      firstname: string | null
      lastname: string
      email: string | null
      orcid: string | null
      created_at: Date
    }, ExtArgs["result"]["authors"]>
    composites: {}
  }

  type authorsGetPayload<S extends boolean | null | undefined | authorsDefaultArgs> = $Result.GetResult<Prisma.$authorsPayload, S>

  type authorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<authorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuthorsCountAggregateInputType | true
    }

  export interface authorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['authors'], meta: { name: 'authors' } }
    /**
     * Find zero or one Authors that matches the filter.
     * @param {authorsFindUniqueArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends authorsFindUniqueArgs>(args: SelectSubset<T, authorsFindUniqueArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Authors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {authorsFindUniqueOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends authorsFindUniqueOrThrowArgs>(args: SelectSubset<T, authorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsFindFirstArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends authorsFindFirstArgs>(args?: SelectSubset<T, authorsFindFirstArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsFindFirstOrThrowArgs} args - Arguments to find a Authors
     * @example
     * // Get one Authors
     * const authors = await prisma.authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends authorsFindFirstOrThrowArgs>(args?: SelectSubset<T, authorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Authors
     * const authors = await prisma.authors.findMany()
     * 
     * // Get first 10 Authors
     * const authors = await prisma.authors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authorsWithIdOnly = await prisma.authors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends authorsFindManyArgs>(args?: SelectSubset<T, authorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Authors.
     * @param {authorsCreateArgs} args - Arguments to create a Authors.
     * @example
     * // Create one Authors
     * const Authors = await prisma.authors.create({
     *   data: {
     *     // ... data to create a Authors
     *   }
     * })
     * 
     */
    create<T extends authorsCreateArgs>(args: SelectSubset<T, authorsCreateArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Authors.
     * @param {authorsCreateManyArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const authors = await prisma.authors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends authorsCreateManyArgs>(args?: SelectSubset<T, authorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Authors and returns the data saved in the database.
     * @param {authorsCreateManyAndReturnArgs} args - Arguments to create many Authors.
     * @example
     * // Create many Authors
     * const authors = await prisma.authors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Authors and only return the `id`
     * const authorsWithIdOnly = await prisma.authors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends authorsCreateManyAndReturnArgs>(args?: SelectSubset<T, authorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Authors.
     * @param {authorsDeleteArgs} args - Arguments to delete one Authors.
     * @example
     * // Delete one Authors
     * const Authors = await prisma.authors.delete({
     *   where: {
     *     // ... filter to delete one Authors
     *   }
     * })
     * 
     */
    delete<T extends authorsDeleteArgs>(args: SelectSubset<T, authorsDeleteArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Authors.
     * @param {authorsUpdateArgs} args - Arguments to update one Authors.
     * @example
     * // Update one Authors
     * const authors = await prisma.authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends authorsUpdateArgs>(args: SelectSubset<T, authorsUpdateArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Authors.
     * @param {authorsDeleteManyArgs} args - Arguments to filter Authors to delete.
     * @example
     * // Delete a few Authors
     * const { count } = await prisma.authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends authorsDeleteManyArgs>(args?: SelectSubset<T, authorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Authors
     * const authors = await prisma.authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends authorsUpdateManyArgs>(args: SelectSubset<T, authorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Authors and returns the data updated in the database.
     * @param {authorsUpdateManyAndReturnArgs} args - Arguments to update many Authors.
     * @example
     * // Update many Authors
     * const authors = await prisma.authors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Authors and only return the `id`
     * const authorsWithIdOnly = await prisma.authors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends authorsUpdateManyAndReturnArgs>(args: SelectSubset<T, authorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Authors.
     * @param {authorsUpsertArgs} args - Arguments to update or create a Authors.
     * @example
     * // Update or create a Authors
     * const authors = await prisma.authors.upsert({
     *   create: {
     *     // ... data to create a Authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Authors we want to update
     *   }
     * })
     */
    upsert<T extends authorsUpsertArgs>(args: SelectSubset<T, authorsUpsertArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsCountArgs} args - Arguments to filter Authors to count.
     * @example
     * // Count the number of Authors
     * const count = await prisma.authors.count({
     *   where: {
     *     // ... the filter for the Authors we want to count
     *   }
     * })
    **/
    count<T extends authorsCountArgs>(
      args?: Subset<T, authorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthorsAggregateArgs>(args: Subset<T, AuthorsAggregateArgs>): Prisma.PrismaPromise<GetAuthorsAggregateType<T>>

    /**
     * Group by Authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {authorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends authorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: authorsGroupByArgs['orderBy'] }
        : { orderBy?: authorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, authorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the authors model
   */
  readonly fields: authorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__authorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication_authors<T extends authors$publication_authorsArgs<ExtArgs> = {}>(args?: Subset<T, authors$publication_authorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the authors model
   */
  interface authorsFieldRefs {
    readonly id: FieldRef<"authors", 'String'>
    readonly firstname: FieldRef<"authors", 'String'>
    readonly lastname: FieldRef<"authors", 'String'>
    readonly email: FieldRef<"authors", 'String'>
    readonly orcid: FieldRef<"authors", 'String'>
    readonly created_at: FieldRef<"authors", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * authors findUnique
   */
  export type authorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where: authorsWhereUniqueInput
  }

  /**
   * authors findUniqueOrThrow
   */
  export type authorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where: authorsWhereUniqueInput
  }

  /**
   * authors findFirst
   */
  export type authorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * authors findFirstOrThrow
   */
  export type authorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for authors.
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of authors.
     */
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * authors findMany
   */
  export type authorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * Filter, which authors to fetch.
     */
    where?: authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of authors to fetch.
     */
    orderBy?: authorsOrderByWithRelationInput | authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing authors.
     */
    cursor?: authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` authors.
     */
    skip?: number
    distinct?: AuthorsScalarFieldEnum | AuthorsScalarFieldEnum[]
  }

  /**
   * authors create
   */
  export type authorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * The data needed to create a authors.
     */
    data: XOR<authorsCreateInput, authorsUncheckedCreateInput>
  }

  /**
   * authors createMany
   */
  export type authorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many authors.
     */
    data: authorsCreateManyInput | authorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * authors createManyAndReturn
   */
  export type authorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * The data used to create many authors.
     */
    data: authorsCreateManyInput | authorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * authors update
   */
  export type authorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * The data needed to update a authors.
     */
    data: XOR<authorsUpdateInput, authorsUncheckedUpdateInput>
    /**
     * Choose, which authors to update.
     */
    where: authorsWhereUniqueInput
  }

  /**
   * authors updateMany
   */
  export type authorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update authors.
     */
    data: XOR<authorsUpdateManyMutationInput, authorsUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorsWhereInput
    /**
     * Limit how many authors to update.
     */
    limit?: number
  }

  /**
   * authors updateManyAndReturn
   */
  export type authorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * The data used to update authors.
     */
    data: XOR<authorsUpdateManyMutationInput, authorsUncheckedUpdateManyInput>
    /**
     * Filter which authors to update
     */
    where?: authorsWhereInput
    /**
     * Limit how many authors to update.
     */
    limit?: number
  }

  /**
   * authors upsert
   */
  export type authorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * The filter to search for the authors to update in case it exists.
     */
    where: authorsWhereUniqueInput
    /**
     * In case the authors found by the `where` argument doesn't exist, create a new authors with this data.
     */
    create: XOR<authorsCreateInput, authorsUncheckedCreateInput>
    /**
     * In case the authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<authorsUpdateInput, authorsUncheckedUpdateInput>
  }

  /**
   * authors delete
   */
  export type authorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
    /**
     * Filter which authors to delete.
     */
    where: authorsWhereUniqueInput
  }

  /**
   * authors deleteMany
   */
  export type authorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which authors to delete
     */
    where?: authorsWhereInput
    /**
     * Limit how many authors to delete.
     */
    limit?: number
  }

  /**
   * authors.publication_authors
   */
  export type authors$publication_authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    where?: publication_authorsWhereInput
    orderBy?: publication_authorsOrderByWithRelationInput | publication_authorsOrderByWithRelationInput[]
    cursor?: publication_authorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_authorsScalarFieldEnum | Publication_authorsScalarFieldEnum[]
  }

  /**
   * authors without action
   */
  export type authorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the authors
     */
    select?: authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the authors
     */
    omit?: authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: authorsInclude<ExtArgs> | null
  }


  /**
   * Model entities
   */

  export type AggregateEntities = {
    _count: EntitiesCountAggregateOutputType | null
    _min: EntitiesMinAggregateOutputType | null
    _max: EntitiesMaxAggregateOutputType | null
  }

  export type EntitiesMinAggregateOutputType = {
    id: string | null
    entity_type: string | null
    entity_name: string | null
    normalized_name: string | null
    description: string | null
  }

  export type EntitiesMaxAggregateOutputType = {
    id: string | null
    entity_type: string | null
    entity_name: string | null
    normalized_name: string | null
    description: string | null
  }

  export type EntitiesCountAggregateOutputType = {
    id: number
    entity_type: number
    entity_name: number
    normalized_name: number
    description: number
    _all: number
  }


  export type EntitiesMinAggregateInputType = {
    id?: true
    entity_type?: true
    entity_name?: true
    normalized_name?: true
    description?: true
  }

  export type EntitiesMaxAggregateInputType = {
    id?: true
    entity_type?: true
    entity_name?: true
    normalized_name?: true
    description?: true
  }

  export type EntitiesCountAggregateInputType = {
    id?: true
    entity_type?: true
    entity_name?: true
    normalized_name?: true
    description?: true
    _all?: true
  }

  export type EntitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities to aggregate.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned entities
    **/
    _count?: true | EntitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntitiesMaxAggregateInputType
  }

  export type GetEntitiesAggregateType<T extends EntitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateEntities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntities[P]>
      : GetScalarType<T[P], AggregateEntities[P]>
  }




  export type entitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: entitiesWhereInput
    orderBy?: entitiesOrderByWithAggregationInput | entitiesOrderByWithAggregationInput[]
    by: EntitiesScalarFieldEnum[] | EntitiesScalarFieldEnum
    having?: entitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntitiesCountAggregateInputType | true
    _min?: EntitiesMinAggregateInputType
    _max?: EntitiesMaxAggregateInputType
  }

  export type EntitiesGroupByOutputType = {
    id: string
    entity_type: string
    entity_name: string
    normalized_name: string | null
    description: string | null
    _count: EntitiesCountAggregateOutputType | null
    _min: EntitiesMinAggregateOutputType | null
    _max: EntitiesMaxAggregateOutputType | null
  }

  type GetEntitiesGroupByPayload<T extends entitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntitiesGroupByOutputType[P]>
            : GetScalarType<T[P], EntitiesGroupByOutputType[P]>
        }
      >
    >


  export type entitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity_type?: boolean
    entity_name?: boolean
    normalized_name?: boolean
    description?: boolean
    publication_entities?: boolean | entities$publication_entitiesArgs<ExtArgs>
    _count?: boolean | EntitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entities"]>

  export type entitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity_type?: boolean
    entity_name?: boolean
    normalized_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["entities"]>

  export type entitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entity_type?: boolean
    entity_name?: boolean
    normalized_name?: boolean
    description?: boolean
  }, ExtArgs["result"]["entities"]>

  export type entitiesSelectScalar = {
    id?: boolean
    entity_type?: boolean
    entity_name?: boolean
    normalized_name?: boolean
    description?: boolean
  }

  export type entitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entity_type" | "entity_name" | "normalized_name" | "description", ExtArgs["result"]["entities"]>
  export type entitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_entities?: boolean | entities$publication_entitiesArgs<ExtArgs>
    _count?: boolean | EntitiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type entitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type entitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $entitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "entities"
    objects: {
      publication_entities: Prisma.$publication_entitiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entity_type: string
      entity_name: string
      normalized_name: string | null
      description: string | null
    }, ExtArgs["result"]["entities"]>
    composites: {}
  }

  type entitiesGetPayload<S extends boolean | null | undefined | entitiesDefaultArgs> = $Result.GetResult<Prisma.$entitiesPayload, S>

  type entitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<entitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntitiesCountAggregateInputType | true
    }

  export interface entitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['entities'], meta: { name: 'entities' } }
    /**
     * Find zero or one Entities that matches the filter.
     * @param {entitiesFindUniqueArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends entitiesFindUniqueArgs>(args: SelectSubset<T, entitiesFindUniqueArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Entities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {entitiesFindUniqueOrThrowArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends entitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, entitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindFirstArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends entitiesFindFirstArgs>(args?: SelectSubset<T, entitiesFindFirstArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Entities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindFirstOrThrowArgs} args - Arguments to find a Entities
     * @example
     * // Get one Entities
     * const entities = await prisma.entities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends entitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, entitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Entities
     * const entities = await prisma.entities.findMany()
     * 
     * // Get first 10 Entities
     * const entities = await prisma.entities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entitiesWithIdOnly = await prisma.entities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends entitiesFindManyArgs>(args?: SelectSubset<T, entitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Entities.
     * @param {entitiesCreateArgs} args - Arguments to create a Entities.
     * @example
     * // Create one Entities
     * const Entities = await prisma.entities.create({
     *   data: {
     *     // ... data to create a Entities
     *   }
     * })
     * 
     */
    create<T extends entitiesCreateArgs>(args: SelectSubset<T, entitiesCreateArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Entities.
     * @param {entitiesCreateManyArgs} args - Arguments to create many Entities.
     * @example
     * // Create many Entities
     * const entities = await prisma.entities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends entitiesCreateManyArgs>(args?: SelectSubset<T, entitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Entities and returns the data saved in the database.
     * @param {entitiesCreateManyAndReturnArgs} args - Arguments to create many Entities.
     * @example
     * // Create many Entities
     * const entities = await prisma.entities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Entities and only return the `id`
     * const entitiesWithIdOnly = await prisma.entities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends entitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, entitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Entities.
     * @param {entitiesDeleteArgs} args - Arguments to delete one Entities.
     * @example
     * // Delete one Entities
     * const Entities = await prisma.entities.delete({
     *   where: {
     *     // ... filter to delete one Entities
     *   }
     * })
     * 
     */
    delete<T extends entitiesDeleteArgs>(args: SelectSubset<T, entitiesDeleteArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Entities.
     * @param {entitiesUpdateArgs} args - Arguments to update one Entities.
     * @example
     * // Update one Entities
     * const entities = await prisma.entities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends entitiesUpdateArgs>(args: SelectSubset<T, entitiesUpdateArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Entities.
     * @param {entitiesDeleteManyArgs} args - Arguments to filter Entities to delete.
     * @example
     * // Delete a few Entities
     * const { count } = await prisma.entities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends entitiesDeleteManyArgs>(args?: SelectSubset<T, entitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Entities
     * const entities = await prisma.entities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends entitiesUpdateManyArgs>(args: SelectSubset<T, entitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Entities and returns the data updated in the database.
     * @param {entitiesUpdateManyAndReturnArgs} args - Arguments to update many Entities.
     * @example
     * // Update many Entities
     * const entities = await prisma.entities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Entities and only return the `id`
     * const entitiesWithIdOnly = await prisma.entities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends entitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, entitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Entities.
     * @param {entitiesUpsertArgs} args - Arguments to update or create a Entities.
     * @example
     * // Update or create a Entities
     * const entities = await prisma.entities.upsert({
     *   create: {
     *     // ... data to create a Entities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Entities we want to update
     *   }
     * })
     */
    upsert<T extends entitiesUpsertArgs>(args: SelectSubset<T, entitiesUpsertArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesCountArgs} args - Arguments to filter Entities to count.
     * @example
     * // Count the number of Entities
     * const count = await prisma.entities.count({
     *   where: {
     *     // ... the filter for the Entities we want to count
     *   }
     * })
    **/
    count<T extends entitiesCountArgs>(
      args?: Subset<T, entitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntitiesAggregateArgs>(args: Subset<T, EntitiesAggregateArgs>): Prisma.PrismaPromise<GetEntitiesAggregateType<T>>

    /**
     * Group by Entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {entitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends entitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: entitiesGroupByArgs['orderBy'] }
        : { orderBy?: entitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, entitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the entities model
   */
  readonly fields: entitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for entities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__entitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication_entities<T extends entities$publication_entitiesArgs<ExtArgs> = {}>(args?: Subset<T, entities$publication_entitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the entities model
   */
  interface entitiesFieldRefs {
    readonly id: FieldRef<"entities", 'String'>
    readonly entity_type: FieldRef<"entities", 'String'>
    readonly entity_name: FieldRef<"entities", 'String'>
    readonly normalized_name: FieldRef<"entities", 'String'>
    readonly description: FieldRef<"entities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * entities findUnique
   */
  export type entitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities findUniqueOrThrow
   */
  export type entitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities findFirst
   */
  export type entitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities.
     */
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }

  /**
   * entities findFirstOrThrow
   */
  export type entitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of entities.
     */
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }

  /**
   * entities findMany
   */
  export type entitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter, which entities to fetch.
     */
    where?: entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of entities to fetch.
     */
    orderBy?: entitiesOrderByWithRelationInput | entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing entities.
     */
    cursor?: entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` entities.
     */
    skip?: number
    distinct?: EntitiesScalarFieldEnum | EntitiesScalarFieldEnum[]
  }

  /**
   * entities create
   */
  export type entitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a entities.
     */
    data: XOR<entitiesCreateInput, entitiesUncheckedCreateInput>
  }

  /**
   * entities createMany
   */
  export type entitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many entities.
     */
    data: entitiesCreateManyInput | entitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * entities createManyAndReturn
   */
  export type entitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * The data used to create many entities.
     */
    data: entitiesCreateManyInput | entitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * entities update
   */
  export type entitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a entities.
     */
    data: XOR<entitiesUpdateInput, entitiesUncheckedUpdateInput>
    /**
     * Choose, which entities to update.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities updateMany
   */
  export type entitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update entities.
     */
    data: XOR<entitiesUpdateManyMutationInput, entitiesUncheckedUpdateManyInput>
    /**
     * Filter which entities to update
     */
    where?: entitiesWhereInput
    /**
     * Limit how many entities to update.
     */
    limit?: number
  }

  /**
   * entities updateManyAndReturn
   */
  export type entitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * The data used to update entities.
     */
    data: XOR<entitiesUpdateManyMutationInput, entitiesUncheckedUpdateManyInput>
    /**
     * Filter which entities to update
     */
    where?: entitiesWhereInput
    /**
     * Limit how many entities to update.
     */
    limit?: number
  }

  /**
   * entities upsert
   */
  export type entitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the entities to update in case it exists.
     */
    where: entitiesWhereUniqueInput
    /**
     * In case the entities found by the `where` argument doesn't exist, create a new entities with this data.
     */
    create: XOR<entitiesCreateInput, entitiesUncheckedCreateInput>
    /**
     * In case the entities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<entitiesUpdateInput, entitiesUncheckedUpdateInput>
  }

  /**
   * entities delete
   */
  export type entitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
    /**
     * Filter which entities to delete.
     */
    where: entitiesWhereUniqueInput
  }

  /**
   * entities deleteMany
   */
  export type entitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which entities to delete
     */
    where?: entitiesWhereInput
    /**
     * Limit how many entities to delete.
     */
    limit?: number
  }

  /**
   * entities.publication_entities
   */
  export type entities$publication_entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    where?: publication_entitiesWhereInput
    orderBy?: publication_entitiesOrderByWithRelationInput | publication_entitiesOrderByWithRelationInput[]
    cursor?: publication_entitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_entitiesScalarFieldEnum | Publication_entitiesScalarFieldEnum[]
  }

  /**
   * entities without action
   */
  export type entitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the entities
     */
    select?: entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the entities
     */
    omit?: entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: entitiesInclude<ExtArgs> | null
  }


  /**
   * Model keywords
   */

  export type AggregateKeywords = {
    _count: KeywordsCountAggregateOutputType | null
    _min: KeywordsMinAggregateOutputType | null
    _max: KeywordsMaxAggregateOutputType | null
  }

  export type KeywordsMinAggregateOutputType = {
    id: string | null
    keyword: string | null
    category: string | null
  }

  export type KeywordsMaxAggregateOutputType = {
    id: string | null
    keyword: string | null
    category: string | null
  }

  export type KeywordsCountAggregateOutputType = {
    id: number
    keyword: number
    category: number
    _all: number
  }


  export type KeywordsMinAggregateInputType = {
    id?: true
    keyword?: true
    category?: true
  }

  export type KeywordsMaxAggregateInputType = {
    id?: true
    keyword?: true
    category?: true
  }

  export type KeywordsCountAggregateInputType = {
    id?: true
    keyword?: true
    category?: true
    _all?: true
  }

  export type KeywordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keywords to aggregate.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned keywords
    **/
    _count?: true | KeywordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KeywordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KeywordsMaxAggregateInputType
  }

  export type GetKeywordsAggregateType<T extends KeywordsAggregateArgs> = {
        [P in keyof T & keyof AggregateKeywords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKeywords[P]>
      : GetScalarType<T[P], AggregateKeywords[P]>
  }




  export type keywordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: keywordsWhereInput
    orderBy?: keywordsOrderByWithAggregationInput | keywordsOrderByWithAggregationInput[]
    by: KeywordsScalarFieldEnum[] | KeywordsScalarFieldEnum
    having?: keywordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KeywordsCountAggregateInputType | true
    _min?: KeywordsMinAggregateInputType
    _max?: KeywordsMaxAggregateInputType
  }

  export type KeywordsGroupByOutputType = {
    id: string
    keyword: string
    category: string | null
    _count: KeywordsCountAggregateOutputType | null
    _min: KeywordsMinAggregateOutputType | null
    _max: KeywordsMaxAggregateOutputType | null
  }

  type GetKeywordsGroupByPayload<T extends keywordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KeywordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KeywordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KeywordsGroupByOutputType[P]>
            : GetScalarType<T[P], KeywordsGroupByOutputType[P]>
        }
      >
    >


  export type keywordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    category?: boolean
    publication_keywords?: boolean | keywords$publication_keywordsArgs<ExtArgs>
    _count?: boolean | KeywordsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["keywords"]>

  export type keywordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    category?: boolean
  }, ExtArgs["result"]["keywords"]>

  export type keywordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    keyword?: boolean
    category?: boolean
  }, ExtArgs["result"]["keywords"]>

  export type keywordsSelectScalar = {
    id?: boolean
    keyword?: boolean
    category?: boolean
  }

  export type keywordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "keyword" | "category", ExtArgs["result"]["keywords"]>
  export type keywordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_keywords?: boolean | keywords$publication_keywordsArgs<ExtArgs>
    _count?: boolean | KeywordsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type keywordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type keywordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $keywordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "keywords"
    objects: {
      publication_keywords: Prisma.$publication_keywordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      keyword: string
      category: string | null
    }, ExtArgs["result"]["keywords"]>
    composites: {}
  }

  type keywordsGetPayload<S extends boolean | null | undefined | keywordsDefaultArgs> = $Result.GetResult<Prisma.$keywordsPayload, S>

  type keywordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<keywordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KeywordsCountAggregateInputType | true
    }

  export interface keywordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['keywords'], meta: { name: 'keywords' } }
    /**
     * Find zero or one Keywords that matches the filter.
     * @param {keywordsFindUniqueArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends keywordsFindUniqueArgs>(args: SelectSubset<T, keywordsFindUniqueArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Keywords that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {keywordsFindUniqueOrThrowArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends keywordsFindUniqueOrThrowArgs>(args: SelectSubset<T, keywordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsFindFirstArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends keywordsFindFirstArgs>(args?: SelectSubset<T, keywordsFindFirstArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Keywords that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsFindFirstOrThrowArgs} args - Arguments to find a Keywords
     * @example
     * // Get one Keywords
     * const keywords = await prisma.keywords.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends keywordsFindFirstOrThrowArgs>(args?: SelectSubset<T, keywordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Keywords
     * const keywords = await prisma.keywords.findMany()
     * 
     * // Get first 10 Keywords
     * const keywords = await prisma.keywords.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const keywordsWithIdOnly = await prisma.keywords.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends keywordsFindManyArgs>(args?: SelectSubset<T, keywordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Keywords.
     * @param {keywordsCreateArgs} args - Arguments to create a Keywords.
     * @example
     * // Create one Keywords
     * const Keywords = await prisma.keywords.create({
     *   data: {
     *     // ... data to create a Keywords
     *   }
     * })
     * 
     */
    create<T extends keywordsCreateArgs>(args: SelectSubset<T, keywordsCreateArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Keywords.
     * @param {keywordsCreateManyArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keywords = await prisma.keywords.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends keywordsCreateManyArgs>(args?: SelectSubset<T, keywordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Keywords and returns the data saved in the database.
     * @param {keywordsCreateManyAndReturnArgs} args - Arguments to create many Keywords.
     * @example
     * // Create many Keywords
     * const keywords = await prisma.keywords.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Keywords and only return the `id`
     * const keywordsWithIdOnly = await prisma.keywords.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends keywordsCreateManyAndReturnArgs>(args?: SelectSubset<T, keywordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Keywords.
     * @param {keywordsDeleteArgs} args - Arguments to delete one Keywords.
     * @example
     * // Delete one Keywords
     * const Keywords = await prisma.keywords.delete({
     *   where: {
     *     // ... filter to delete one Keywords
     *   }
     * })
     * 
     */
    delete<T extends keywordsDeleteArgs>(args: SelectSubset<T, keywordsDeleteArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Keywords.
     * @param {keywordsUpdateArgs} args - Arguments to update one Keywords.
     * @example
     * // Update one Keywords
     * const keywords = await prisma.keywords.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends keywordsUpdateArgs>(args: SelectSubset<T, keywordsUpdateArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Keywords.
     * @param {keywordsDeleteManyArgs} args - Arguments to filter Keywords to delete.
     * @example
     * // Delete a few Keywords
     * const { count } = await prisma.keywords.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends keywordsDeleteManyArgs>(args?: SelectSubset<T, keywordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Keywords
     * const keywords = await prisma.keywords.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends keywordsUpdateManyArgs>(args: SelectSubset<T, keywordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Keywords and returns the data updated in the database.
     * @param {keywordsUpdateManyAndReturnArgs} args - Arguments to update many Keywords.
     * @example
     * // Update many Keywords
     * const keywords = await prisma.keywords.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Keywords and only return the `id`
     * const keywordsWithIdOnly = await prisma.keywords.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends keywordsUpdateManyAndReturnArgs>(args: SelectSubset<T, keywordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Keywords.
     * @param {keywordsUpsertArgs} args - Arguments to update or create a Keywords.
     * @example
     * // Update or create a Keywords
     * const keywords = await prisma.keywords.upsert({
     *   create: {
     *     // ... data to create a Keywords
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Keywords we want to update
     *   }
     * })
     */
    upsert<T extends keywordsUpsertArgs>(args: SelectSubset<T, keywordsUpsertArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsCountArgs} args - Arguments to filter Keywords to count.
     * @example
     * // Count the number of Keywords
     * const count = await prisma.keywords.count({
     *   where: {
     *     // ... the filter for the Keywords we want to count
     *   }
     * })
    **/
    count<T extends keywordsCountArgs>(
      args?: Subset<T, keywordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KeywordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KeywordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KeywordsAggregateArgs>(args: Subset<T, KeywordsAggregateArgs>): Prisma.PrismaPromise<GetKeywordsAggregateType<T>>

    /**
     * Group by Keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {keywordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends keywordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: keywordsGroupByArgs['orderBy'] }
        : { orderBy?: keywordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, keywordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKeywordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the keywords model
   */
  readonly fields: keywordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for keywords.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__keywordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication_keywords<T extends keywords$publication_keywordsArgs<ExtArgs> = {}>(args?: Subset<T, keywords$publication_keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the keywords model
   */
  interface keywordsFieldRefs {
    readonly id: FieldRef<"keywords", 'String'>
    readonly keyword: FieldRef<"keywords", 'String'>
    readonly category: FieldRef<"keywords", 'String'>
  }
    

  // Custom InputTypes
  /**
   * keywords findUnique
   */
  export type keywordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords findUniqueOrThrow
   */
  export type keywordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords findFirst
   */
  export type keywordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keywords.
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keywords.
     */
    distinct?: KeywordsScalarFieldEnum | KeywordsScalarFieldEnum[]
  }

  /**
   * keywords findFirstOrThrow
   */
  export type keywordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for keywords.
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of keywords.
     */
    distinct?: KeywordsScalarFieldEnum | KeywordsScalarFieldEnum[]
  }

  /**
   * keywords findMany
   */
  export type keywordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * Filter, which keywords to fetch.
     */
    where?: keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of keywords to fetch.
     */
    orderBy?: keywordsOrderByWithRelationInput | keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing keywords.
     */
    cursor?: keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` keywords.
     */
    skip?: number
    distinct?: KeywordsScalarFieldEnum | KeywordsScalarFieldEnum[]
  }

  /**
   * keywords create
   */
  export type keywordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * The data needed to create a keywords.
     */
    data: XOR<keywordsCreateInput, keywordsUncheckedCreateInput>
  }

  /**
   * keywords createMany
   */
  export type keywordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many keywords.
     */
    data: keywordsCreateManyInput | keywordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * keywords createManyAndReturn
   */
  export type keywordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * The data used to create many keywords.
     */
    data: keywordsCreateManyInput | keywordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * keywords update
   */
  export type keywordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * The data needed to update a keywords.
     */
    data: XOR<keywordsUpdateInput, keywordsUncheckedUpdateInput>
    /**
     * Choose, which keywords to update.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords updateMany
   */
  export type keywordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update keywords.
     */
    data: XOR<keywordsUpdateManyMutationInput, keywordsUncheckedUpdateManyInput>
    /**
     * Filter which keywords to update
     */
    where?: keywordsWhereInput
    /**
     * Limit how many keywords to update.
     */
    limit?: number
  }

  /**
   * keywords updateManyAndReturn
   */
  export type keywordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * The data used to update keywords.
     */
    data: XOR<keywordsUpdateManyMutationInput, keywordsUncheckedUpdateManyInput>
    /**
     * Filter which keywords to update
     */
    where?: keywordsWhereInput
    /**
     * Limit how many keywords to update.
     */
    limit?: number
  }

  /**
   * keywords upsert
   */
  export type keywordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * The filter to search for the keywords to update in case it exists.
     */
    where: keywordsWhereUniqueInput
    /**
     * In case the keywords found by the `where` argument doesn't exist, create a new keywords with this data.
     */
    create: XOR<keywordsCreateInput, keywordsUncheckedCreateInput>
    /**
     * In case the keywords was found with the provided `where` argument, update it with this data.
     */
    update: XOR<keywordsUpdateInput, keywordsUncheckedUpdateInput>
  }

  /**
   * keywords delete
   */
  export type keywordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
    /**
     * Filter which keywords to delete.
     */
    where: keywordsWhereUniqueInput
  }

  /**
   * keywords deleteMany
   */
  export type keywordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which keywords to delete
     */
    where?: keywordsWhereInput
    /**
     * Limit how many keywords to delete.
     */
    limit?: number
  }

  /**
   * keywords.publication_keywords
   */
  export type keywords$publication_keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    where?: publication_keywordsWhereInput
    orderBy?: publication_keywordsOrderByWithRelationInput | publication_keywordsOrderByWithRelationInput[]
    cursor?: publication_keywordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_keywordsScalarFieldEnum | Publication_keywordsScalarFieldEnum[]
  }

  /**
   * keywords without action
   */
  export type keywordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the keywords
     */
    select?: keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the keywords
     */
    omit?: keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: keywordsInclude<ExtArgs> | null
  }


  /**
   * Model mesh_terms
   */

  export type AggregateMesh_terms = {
    _count: Mesh_termsCountAggregateOutputType | null
    _min: Mesh_termsMinAggregateOutputType | null
    _max: Mesh_termsMaxAggregateOutputType | null
  }

  export type Mesh_termsMinAggregateOutputType = {
    id: string | null
    term: string | null
    tree_number: string | null
  }

  export type Mesh_termsMaxAggregateOutputType = {
    id: string | null
    term: string | null
    tree_number: string | null
  }

  export type Mesh_termsCountAggregateOutputType = {
    id: number
    term: number
    tree_number: number
    _all: number
  }


  export type Mesh_termsMinAggregateInputType = {
    id?: true
    term?: true
    tree_number?: true
  }

  export type Mesh_termsMaxAggregateInputType = {
    id?: true
    term?: true
    tree_number?: true
  }

  export type Mesh_termsCountAggregateInputType = {
    id?: true
    term?: true
    tree_number?: true
    _all?: true
  }

  export type Mesh_termsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mesh_terms to aggregate.
     */
    where?: mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mesh_terms to fetch.
     */
    orderBy?: mesh_termsOrderByWithRelationInput | mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mesh_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned mesh_terms
    **/
    _count?: true | Mesh_termsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Mesh_termsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Mesh_termsMaxAggregateInputType
  }

  export type GetMesh_termsAggregateType<T extends Mesh_termsAggregateArgs> = {
        [P in keyof T & keyof AggregateMesh_terms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMesh_terms[P]>
      : GetScalarType<T[P], AggregateMesh_terms[P]>
  }




  export type mesh_termsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: mesh_termsWhereInput
    orderBy?: mesh_termsOrderByWithAggregationInput | mesh_termsOrderByWithAggregationInput[]
    by: Mesh_termsScalarFieldEnum[] | Mesh_termsScalarFieldEnum
    having?: mesh_termsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Mesh_termsCountAggregateInputType | true
    _min?: Mesh_termsMinAggregateInputType
    _max?: Mesh_termsMaxAggregateInputType
  }

  export type Mesh_termsGroupByOutputType = {
    id: string
    term: string
    tree_number: string | null
    _count: Mesh_termsCountAggregateOutputType | null
    _min: Mesh_termsMinAggregateOutputType | null
    _max: Mesh_termsMaxAggregateOutputType | null
  }

  type GetMesh_termsGroupByPayload<T extends mesh_termsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Mesh_termsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Mesh_termsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Mesh_termsGroupByOutputType[P]>
            : GetScalarType<T[P], Mesh_termsGroupByOutputType[P]>
        }
      >
    >


  export type mesh_termsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    tree_number?: boolean
    publication_mesh_terms?: boolean | mesh_terms$publication_mesh_termsArgs<ExtArgs>
    _count?: boolean | Mesh_termsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mesh_terms"]>

  export type mesh_termsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    tree_number?: boolean
  }, ExtArgs["result"]["mesh_terms"]>

  export type mesh_termsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    term?: boolean
    tree_number?: boolean
  }, ExtArgs["result"]["mesh_terms"]>

  export type mesh_termsSelectScalar = {
    id?: boolean
    term?: boolean
    tree_number?: boolean
  }

  export type mesh_termsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "term" | "tree_number", ExtArgs["result"]["mesh_terms"]>
  export type mesh_termsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_mesh_terms?: boolean | mesh_terms$publication_mesh_termsArgs<ExtArgs>
    _count?: boolean | Mesh_termsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type mesh_termsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type mesh_termsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $mesh_termsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "mesh_terms"
    objects: {
      publication_mesh_terms: Prisma.$publication_mesh_termsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      term: string
      tree_number: string | null
    }, ExtArgs["result"]["mesh_terms"]>
    composites: {}
  }

  type mesh_termsGetPayload<S extends boolean | null | undefined | mesh_termsDefaultArgs> = $Result.GetResult<Prisma.$mesh_termsPayload, S>

  type mesh_termsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<mesh_termsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Mesh_termsCountAggregateInputType | true
    }

  export interface mesh_termsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['mesh_terms'], meta: { name: 'mesh_terms' } }
    /**
     * Find zero or one Mesh_terms that matches the filter.
     * @param {mesh_termsFindUniqueArgs} args - Arguments to find a Mesh_terms
     * @example
     * // Get one Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends mesh_termsFindUniqueArgs>(args: SelectSubset<T, mesh_termsFindUniqueArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mesh_terms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {mesh_termsFindUniqueOrThrowArgs} args - Arguments to find a Mesh_terms
     * @example
     * // Get one Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends mesh_termsFindUniqueOrThrowArgs>(args: SelectSubset<T, mesh_termsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mesh_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesh_termsFindFirstArgs} args - Arguments to find a Mesh_terms
     * @example
     * // Get one Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends mesh_termsFindFirstArgs>(args?: SelectSubset<T, mesh_termsFindFirstArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mesh_terms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesh_termsFindFirstOrThrowArgs} args - Arguments to find a Mesh_terms
     * @example
     * // Get one Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends mesh_termsFindFirstOrThrowArgs>(args?: SelectSubset<T, mesh_termsFindFirstOrThrowArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mesh_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesh_termsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.findMany()
     * 
     * // Get first 10 Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mesh_termsWithIdOnly = await prisma.mesh_terms.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends mesh_termsFindManyArgs>(args?: SelectSubset<T, mesh_termsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mesh_terms.
     * @param {mesh_termsCreateArgs} args - Arguments to create a Mesh_terms.
     * @example
     * // Create one Mesh_terms
     * const Mesh_terms = await prisma.mesh_terms.create({
     *   data: {
     *     // ... data to create a Mesh_terms
     *   }
     * })
     * 
     */
    create<T extends mesh_termsCreateArgs>(args: SelectSubset<T, mesh_termsCreateArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mesh_terms.
     * @param {mesh_termsCreateManyArgs} args - Arguments to create many Mesh_terms.
     * @example
     * // Create many Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends mesh_termsCreateManyArgs>(args?: SelectSubset<T, mesh_termsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mesh_terms and returns the data saved in the database.
     * @param {mesh_termsCreateManyAndReturnArgs} args - Arguments to create many Mesh_terms.
     * @example
     * // Create many Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mesh_terms and only return the `id`
     * const mesh_termsWithIdOnly = await prisma.mesh_terms.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends mesh_termsCreateManyAndReturnArgs>(args?: SelectSubset<T, mesh_termsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mesh_terms.
     * @param {mesh_termsDeleteArgs} args - Arguments to delete one Mesh_terms.
     * @example
     * // Delete one Mesh_terms
     * const Mesh_terms = await prisma.mesh_terms.delete({
     *   where: {
     *     // ... filter to delete one Mesh_terms
     *   }
     * })
     * 
     */
    delete<T extends mesh_termsDeleteArgs>(args: SelectSubset<T, mesh_termsDeleteArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mesh_terms.
     * @param {mesh_termsUpdateArgs} args - Arguments to update one Mesh_terms.
     * @example
     * // Update one Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends mesh_termsUpdateArgs>(args: SelectSubset<T, mesh_termsUpdateArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mesh_terms.
     * @param {mesh_termsDeleteManyArgs} args - Arguments to filter Mesh_terms to delete.
     * @example
     * // Delete a few Mesh_terms
     * const { count } = await prisma.mesh_terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends mesh_termsDeleteManyArgs>(args?: SelectSubset<T, mesh_termsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesh_termsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends mesh_termsUpdateManyArgs>(args: SelectSubset<T, mesh_termsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mesh_terms and returns the data updated in the database.
     * @param {mesh_termsUpdateManyAndReturnArgs} args - Arguments to update many Mesh_terms.
     * @example
     * // Update many Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mesh_terms and only return the `id`
     * const mesh_termsWithIdOnly = await prisma.mesh_terms.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends mesh_termsUpdateManyAndReturnArgs>(args: SelectSubset<T, mesh_termsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mesh_terms.
     * @param {mesh_termsUpsertArgs} args - Arguments to update or create a Mesh_terms.
     * @example
     * // Update or create a Mesh_terms
     * const mesh_terms = await prisma.mesh_terms.upsert({
     *   create: {
     *     // ... data to create a Mesh_terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mesh_terms we want to update
     *   }
     * })
     */
    upsert<T extends mesh_termsUpsertArgs>(args: SelectSubset<T, mesh_termsUpsertArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesh_termsCountArgs} args - Arguments to filter Mesh_terms to count.
     * @example
     * // Count the number of Mesh_terms
     * const count = await prisma.mesh_terms.count({
     *   where: {
     *     // ... the filter for the Mesh_terms we want to count
     *   }
     * })
    **/
    count<T extends mesh_termsCountArgs>(
      args?: Subset<T, mesh_termsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Mesh_termsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Mesh_termsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Mesh_termsAggregateArgs>(args: Subset<T, Mesh_termsAggregateArgs>): Prisma.PrismaPromise<GetMesh_termsAggregateType<T>>

    /**
     * Group by Mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {mesh_termsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends mesh_termsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: mesh_termsGroupByArgs['orderBy'] }
        : { orderBy?: mesh_termsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, mesh_termsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMesh_termsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the mesh_terms model
   */
  readonly fields: mesh_termsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for mesh_terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__mesh_termsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication_mesh_terms<T extends mesh_terms$publication_mesh_termsArgs<ExtArgs> = {}>(args?: Subset<T, mesh_terms$publication_mesh_termsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the mesh_terms model
   */
  interface mesh_termsFieldRefs {
    readonly id: FieldRef<"mesh_terms", 'String'>
    readonly term: FieldRef<"mesh_terms", 'String'>
    readonly tree_number: FieldRef<"mesh_terms", 'String'>
  }
    

  // Custom InputTypes
  /**
   * mesh_terms findUnique
   */
  export type mesh_termsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which mesh_terms to fetch.
     */
    where: mesh_termsWhereUniqueInput
  }

  /**
   * mesh_terms findUniqueOrThrow
   */
  export type mesh_termsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which mesh_terms to fetch.
     */
    where: mesh_termsWhereUniqueInput
  }

  /**
   * mesh_terms findFirst
   */
  export type mesh_termsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which mesh_terms to fetch.
     */
    where?: mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mesh_terms to fetch.
     */
    orderBy?: mesh_termsOrderByWithRelationInput | mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mesh_terms.
     */
    cursor?: mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mesh_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mesh_terms.
     */
    distinct?: Mesh_termsScalarFieldEnum | Mesh_termsScalarFieldEnum[]
  }

  /**
   * mesh_terms findFirstOrThrow
   */
  export type mesh_termsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which mesh_terms to fetch.
     */
    where?: mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mesh_terms to fetch.
     */
    orderBy?: mesh_termsOrderByWithRelationInput | mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for mesh_terms.
     */
    cursor?: mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mesh_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of mesh_terms.
     */
    distinct?: Mesh_termsScalarFieldEnum | Mesh_termsScalarFieldEnum[]
  }

  /**
   * mesh_terms findMany
   */
  export type mesh_termsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which mesh_terms to fetch.
     */
    where?: mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of mesh_terms to fetch.
     */
    orderBy?: mesh_termsOrderByWithRelationInput | mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing mesh_terms.
     */
    cursor?: mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` mesh_terms.
     */
    skip?: number
    distinct?: Mesh_termsScalarFieldEnum | Mesh_termsScalarFieldEnum[]
  }

  /**
   * mesh_terms create
   */
  export type mesh_termsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * The data needed to create a mesh_terms.
     */
    data: XOR<mesh_termsCreateInput, mesh_termsUncheckedCreateInput>
  }

  /**
   * mesh_terms createMany
   */
  export type mesh_termsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many mesh_terms.
     */
    data: mesh_termsCreateManyInput | mesh_termsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mesh_terms createManyAndReturn
   */
  export type mesh_termsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * The data used to create many mesh_terms.
     */
    data: mesh_termsCreateManyInput | mesh_termsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * mesh_terms update
   */
  export type mesh_termsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * The data needed to update a mesh_terms.
     */
    data: XOR<mesh_termsUpdateInput, mesh_termsUncheckedUpdateInput>
    /**
     * Choose, which mesh_terms to update.
     */
    where: mesh_termsWhereUniqueInput
  }

  /**
   * mesh_terms updateMany
   */
  export type mesh_termsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update mesh_terms.
     */
    data: XOR<mesh_termsUpdateManyMutationInput, mesh_termsUncheckedUpdateManyInput>
    /**
     * Filter which mesh_terms to update
     */
    where?: mesh_termsWhereInput
    /**
     * Limit how many mesh_terms to update.
     */
    limit?: number
  }

  /**
   * mesh_terms updateManyAndReturn
   */
  export type mesh_termsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * The data used to update mesh_terms.
     */
    data: XOR<mesh_termsUpdateManyMutationInput, mesh_termsUncheckedUpdateManyInput>
    /**
     * Filter which mesh_terms to update
     */
    where?: mesh_termsWhereInput
    /**
     * Limit how many mesh_terms to update.
     */
    limit?: number
  }

  /**
   * mesh_terms upsert
   */
  export type mesh_termsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * The filter to search for the mesh_terms to update in case it exists.
     */
    where: mesh_termsWhereUniqueInput
    /**
     * In case the mesh_terms found by the `where` argument doesn't exist, create a new mesh_terms with this data.
     */
    create: XOR<mesh_termsCreateInput, mesh_termsUncheckedCreateInput>
    /**
     * In case the mesh_terms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<mesh_termsUpdateInput, mesh_termsUncheckedUpdateInput>
  }

  /**
   * mesh_terms delete
   */
  export type mesh_termsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
    /**
     * Filter which mesh_terms to delete.
     */
    where: mesh_termsWhereUniqueInput
  }

  /**
   * mesh_terms deleteMany
   */
  export type mesh_termsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which mesh_terms to delete
     */
    where?: mesh_termsWhereInput
    /**
     * Limit how many mesh_terms to delete.
     */
    limit?: number
  }

  /**
   * mesh_terms.publication_mesh_terms
   */
  export type mesh_terms$publication_mesh_termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    where?: publication_mesh_termsWhereInput
    orderBy?: publication_mesh_termsOrderByWithRelationInput | publication_mesh_termsOrderByWithRelationInput[]
    cursor?: publication_mesh_termsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_mesh_termsScalarFieldEnum | Publication_mesh_termsScalarFieldEnum[]
  }

  /**
   * mesh_terms without action
   */
  export type mesh_termsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the mesh_terms
     */
    select?: mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the mesh_terms
     */
    omit?: mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: mesh_termsInclude<ExtArgs> | null
  }


  /**
   * Model publication_authors
   */

  export type AggregatePublication_authors = {
    _count: Publication_authorsCountAggregateOutputType | null
    _avg: Publication_authorsAvgAggregateOutputType | null
    _sum: Publication_authorsSumAggregateOutputType | null
    _min: Publication_authorsMinAggregateOutputType | null
    _max: Publication_authorsMaxAggregateOutputType | null
  }

  export type Publication_authorsAvgAggregateOutputType = {
    author_order: number | null
  }

  export type Publication_authorsSumAggregateOutputType = {
    author_order: number | null
  }

  export type Publication_authorsMinAggregateOutputType = {
    publication_id: string | null
    author_id: string | null
    author_order: number | null
    affiliation: string | null
  }

  export type Publication_authorsMaxAggregateOutputType = {
    publication_id: string | null
    author_id: string | null
    author_order: number | null
    affiliation: string | null
  }

  export type Publication_authorsCountAggregateOutputType = {
    publication_id: number
    author_id: number
    author_order: number
    affiliation: number
    _all: number
  }


  export type Publication_authorsAvgAggregateInputType = {
    author_order?: true
  }

  export type Publication_authorsSumAggregateInputType = {
    author_order?: true
  }

  export type Publication_authorsMinAggregateInputType = {
    publication_id?: true
    author_id?: true
    author_order?: true
    affiliation?: true
  }

  export type Publication_authorsMaxAggregateInputType = {
    publication_id?: true
    author_id?: true
    author_order?: true
    affiliation?: true
  }

  export type Publication_authorsCountAggregateInputType = {
    publication_id?: true
    author_id?: true
    author_order?: true
    affiliation?: true
    _all?: true
  }

  export type Publication_authorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_authors to aggregate.
     */
    where?: publication_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_authors to fetch.
     */
    orderBy?: publication_authorsOrderByWithRelationInput | publication_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publication_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publication_authors
    **/
    _count?: true | Publication_authorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Publication_authorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Publication_authorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Publication_authorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Publication_authorsMaxAggregateInputType
  }

  export type GetPublication_authorsAggregateType<T extends Publication_authorsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication_authors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication_authors[P]>
      : GetScalarType<T[P], AggregatePublication_authors[P]>
  }




  export type publication_authorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_authorsWhereInput
    orderBy?: publication_authorsOrderByWithAggregationInput | publication_authorsOrderByWithAggregationInput[]
    by: Publication_authorsScalarFieldEnum[] | Publication_authorsScalarFieldEnum
    having?: publication_authorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Publication_authorsCountAggregateInputType | true
    _avg?: Publication_authorsAvgAggregateInputType
    _sum?: Publication_authorsSumAggregateInputType
    _min?: Publication_authorsMinAggregateInputType
    _max?: Publication_authorsMaxAggregateInputType
  }

  export type Publication_authorsGroupByOutputType = {
    publication_id: string
    author_id: string
    author_order: number
    affiliation: string | null
    _count: Publication_authorsCountAggregateOutputType | null
    _avg: Publication_authorsAvgAggregateOutputType | null
    _sum: Publication_authorsSumAggregateOutputType | null
    _min: Publication_authorsMinAggregateOutputType | null
    _max: Publication_authorsMaxAggregateOutputType | null
  }

  type GetPublication_authorsGroupByPayload<T extends publication_authorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Publication_authorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Publication_authorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Publication_authorsGroupByOutputType[P]>
            : GetScalarType<T[P], Publication_authorsGroupByOutputType[P]>
        }
      >
    >


  export type publication_authorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    author_id?: boolean
    author_order?: boolean
    affiliation?: boolean
    authors?: boolean | authorsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_authors"]>

  export type publication_authorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    author_id?: boolean
    author_order?: boolean
    affiliation?: boolean
    authors?: boolean | authorsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_authors"]>

  export type publication_authorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    author_id?: boolean
    author_order?: boolean
    affiliation?: boolean
    authors?: boolean | authorsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_authors"]>

  export type publication_authorsSelectScalar = {
    publication_id?: boolean
    author_id?: boolean
    author_order?: boolean
    affiliation?: boolean
  }

  export type publication_authorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"publication_id" | "author_id" | "author_order" | "affiliation", ExtArgs["result"]["publication_authors"]>
  export type publication_authorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authors?: boolean | authorsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_authorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authors?: boolean | authorsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_authorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authors?: boolean | authorsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }

  export type $publication_authorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publication_authors"
    objects: {
      authors: Prisma.$authorsPayload<ExtArgs>
      publications: Prisma.$publicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      publication_id: string
      author_id: string
      author_order: number
      affiliation: string | null
    }, ExtArgs["result"]["publication_authors"]>
    composites: {}
  }

  type publication_authorsGetPayload<S extends boolean | null | undefined | publication_authorsDefaultArgs> = $Result.GetResult<Prisma.$publication_authorsPayload, S>

  type publication_authorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publication_authorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Publication_authorsCountAggregateInputType | true
    }

  export interface publication_authorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publication_authors'], meta: { name: 'publication_authors' } }
    /**
     * Find zero or one Publication_authors that matches the filter.
     * @param {publication_authorsFindUniqueArgs} args - Arguments to find a Publication_authors
     * @example
     * // Get one Publication_authors
     * const publication_authors = await prisma.publication_authors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publication_authorsFindUniqueArgs>(args: SelectSubset<T, publication_authorsFindUniqueArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publication_authors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publication_authorsFindUniqueOrThrowArgs} args - Arguments to find a Publication_authors
     * @example
     * // Get one Publication_authors
     * const publication_authors = await prisma.publication_authors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publication_authorsFindUniqueOrThrowArgs>(args: SelectSubset<T, publication_authorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_authorsFindFirstArgs} args - Arguments to find a Publication_authors
     * @example
     * // Get one Publication_authors
     * const publication_authors = await prisma.publication_authors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publication_authorsFindFirstArgs>(args?: SelectSubset<T, publication_authorsFindFirstArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_authors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_authorsFindFirstOrThrowArgs} args - Arguments to find a Publication_authors
     * @example
     * // Get one Publication_authors
     * const publication_authors = await prisma.publication_authors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publication_authorsFindFirstOrThrowArgs>(args?: SelectSubset<T, publication_authorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publication_authors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_authorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publication_authors
     * const publication_authors = await prisma.publication_authors.findMany()
     * 
     * // Get first 10 Publication_authors
     * const publication_authors = await prisma.publication_authors.findMany({ take: 10 })
     * 
     * // Only select the `publication_id`
     * const publication_authorsWithPublication_idOnly = await prisma.publication_authors.findMany({ select: { publication_id: true } })
     * 
     */
    findMany<T extends publication_authorsFindManyArgs>(args?: SelectSubset<T, publication_authorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publication_authors.
     * @param {publication_authorsCreateArgs} args - Arguments to create a Publication_authors.
     * @example
     * // Create one Publication_authors
     * const Publication_authors = await prisma.publication_authors.create({
     *   data: {
     *     // ... data to create a Publication_authors
     *   }
     * })
     * 
     */
    create<T extends publication_authorsCreateArgs>(args: SelectSubset<T, publication_authorsCreateArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publication_authors.
     * @param {publication_authorsCreateManyArgs} args - Arguments to create many Publication_authors.
     * @example
     * // Create many Publication_authors
     * const publication_authors = await prisma.publication_authors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publication_authorsCreateManyArgs>(args?: SelectSubset<T, publication_authorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publication_authors and returns the data saved in the database.
     * @param {publication_authorsCreateManyAndReturnArgs} args - Arguments to create many Publication_authors.
     * @example
     * // Create many Publication_authors
     * const publication_authors = await prisma.publication_authors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publication_authors and only return the `publication_id`
     * const publication_authorsWithPublication_idOnly = await prisma.publication_authors.createManyAndReturn({
     *   select: { publication_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publication_authorsCreateManyAndReturnArgs>(args?: SelectSubset<T, publication_authorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publication_authors.
     * @param {publication_authorsDeleteArgs} args - Arguments to delete one Publication_authors.
     * @example
     * // Delete one Publication_authors
     * const Publication_authors = await prisma.publication_authors.delete({
     *   where: {
     *     // ... filter to delete one Publication_authors
     *   }
     * })
     * 
     */
    delete<T extends publication_authorsDeleteArgs>(args: SelectSubset<T, publication_authorsDeleteArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publication_authors.
     * @param {publication_authorsUpdateArgs} args - Arguments to update one Publication_authors.
     * @example
     * // Update one Publication_authors
     * const publication_authors = await prisma.publication_authors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publication_authorsUpdateArgs>(args: SelectSubset<T, publication_authorsUpdateArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publication_authors.
     * @param {publication_authorsDeleteManyArgs} args - Arguments to filter Publication_authors to delete.
     * @example
     * // Delete a few Publication_authors
     * const { count } = await prisma.publication_authors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publication_authorsDeleteManyArgs>(args?: SelectSubset<T, publication_authorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_authorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publication_authors
     * const publication_authors = await prisma.publication_authors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publication_authorsUpdateManyArgs>(args: SelectSubset<T, publication_authorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_authors and returns the data updated in the database.
     * @param {publication_authorsUpdateManyAndReturnArgs} args - Arguments to update many Publication_authors.
     * @example
     * // Update many Publication_authors
     * const publication_authors = await prisma.publication_authors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publication_authors and only return the `publication_id`
     * const publication_authorsWithPublication_idOnly = await prisma.publication_authors.updateManyAndReturn({
     *   select: { publication_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publication_authorsUpdateManyAndReturnArgs>(args: SelectSubset<T, publication_authorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publication_authors.
     * @param {publication_authorsUpsertArgs} args - Arguments to update or create a Publication_authors.
     * @example
     * // Update or create a Publication_authors
     * const publication_authors = await prisma.publication_authors.upsert({
     *   create: {
     *     // ... data to create a Publication_authors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication_authors we want to update
     *   }
     * })
     */
    upsert<T extends publication_authorsUpsertArgs>(args: SelectSubset<T, publication_authorsUpsertArgs<ExtArgs>>): Prisma__publication_authorsClient<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publication_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_authorsCountArgs} args - Arguments to filter Publication_authors to count.
     * @example
     * // Count the number of Publication_authors
     * const count = await prisma.publication_authors.count({
     *   where: {
     *     // ... the filter for the Publication_authors we want to count
     *   }
     * })
    **/
    count<T extends publication_authorsCountArgs>(
      args?: Subset<T, publication_authorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Publication_authorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publication_authorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Publication_authorsAggregateArgs>(args: Subset<T, Publication_authorsAggregateArgs>): Prisma.PrismaPromise<GetPublication_authorsAggregateType<T>>

    /**
     * Group by Publication_authors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_authorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publication_authorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publication_authorsGroupByArgs['orderBy'] }
        : { orderBy?: publication_authorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publication_authorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublication_authorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publication_authors model
   */
  readonly fields: publication_authorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publication_authors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publication_authorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    authors<T extends authorsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, authorsDefaultArgs<ExtArgs>>): Prisma__authorsClient<$Result.GetResult<Prisma.$authorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publications<T extends publicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publicationsDefaultArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publication_authors model
   */
  interface publication_authorsFieldRefs {
    readonly publication_id: FieldRef<"publication_authors", 'String'>
    readonly author_id: FieldRef<"publication_authors", 'String'>
    readonly author_order: FieldRef<"publication_authors", 'Int'>
    readonly affiliation: FieldRef<"publication_authors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * publication_authors findUnique
   */
  export type publication_authorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * Filter, which publication_authors to fetch.
     */
    where: publication_authorsWhereUniqueInput
  }

  /**
   * publication_authors findUniqueOrThrow
   */
  export type publication_authorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * Filter, which publication_authors to fetch.
     */
    where: publication_authorsWhereUniqueInput
  }

  /**
   * publication_authors findFirst
   */
  export type publication_authorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * Filter, which publication_authors to fetch.
     */
    where?: publication_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_authors to fetch.
     */
    orderBy?: publication_authorsOrderByWithRelationInput | publication_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_authors.
     */
    cursor?: publication_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_authors.
     */
    distinct?: Publication_authorsScalarFieldEnum | Publication_authorsScalarFieldEnum[]
  }

  /**
   * publication_authors findFirstOrThrow
   */
  export type publication_authorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * Filter, which publication_authors to fetch.
     */
    where?: publication_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_authors to fetch.
     */
    orderBy?: publication_authorsOrderByWithRelationInput | publication_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_authors.
     */
    cursor?: publication_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_authors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_authors.
     */
    distinct?: Publication_authorsScalarFieldEnum | Publication_authorsScalarFieldEnum[]
  }

  /**
   * publication_authors findMany
   */
  export type publication_authorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * Filter, which publication_authors to fetch.
     */
    where?: publication_authorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_authors to fetch.
     */
    orderBy?: publication_authorsOrderByWithRelationInput | publication_authorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publication_authors.
     */
    cursor?: publication_authorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_authors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_authors.
     */
    skip?: number
    distinct?: Publication_authorsScalarFieldEnum | Publication_authorsScalarFieldEnum[]
  }

  /**
   * publication_authors create
   */
  export type publication_authorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * The data needed to create a publication_authors.
     */
    data: XOR<publication_authorsCreateInput, publication_authorsUncheckedCreateInput>
  }

  /**
   * publication_authors createMany
   */
  export type publication_authorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publication_authors.
     */
    data: publication_authorsCreateManyInput | publication_authorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publication_authors createManyAndReturn
   */
  export type publication_authorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * The data used to create many publication_authors.
     */
    data: publication_authorsCreateManyInput | publication_authorsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_authors update
   */
  export type publication_authorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * The data needed to update a publication_authors.
     */
    data: XOR<publication_authorsUpdateInput, publication_authorsUncheckedUpdateInput>
    /**
     * Choose, which publication_authors to update.
     */
    where: publication_authorsWhereUniqueInput
  }

  /**
   * publication_authors updateMany
   */
  export type publication_authorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publication_authors.
     */
    data: XOR<publication_authorsUpdateManyMutationInput, publication_authorsUncheckedUpdateManyInput>
    /**
     * Filter which publication_authors to update
     */
    where?: publication_authorsWhereInput
    /**
     * Limit how many publication_authors to update.
     */
    limit?: number
  }

  /**
   * publication_authors updateManyAndReturn
   */
  export type publication_authorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * The data used to update publication_authors.
     */
    data: XOR<publication_authorsUpdateManyMutationInput, publication_authorsUncheckedUpdateManyInput>
    /**
     * Filter which publication_authors to update
     */
    where?: publication_authorsWhereInput
    /**
     * Limit how many publication_authors to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_authors upsert
   */
  export type publication_authorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * The filter to search for the publication_authors to update in case it exists.
     */
    where: publication_authorsWhereUniqueInput
    /**
     * In case the publication_authors found by the `where` argument doesn't exist, create a new publication_authors with this data.
     */
    create: XOR<publication_authorsCreateInput, publication_authorsUncheckedCreateInput>
    /**
     * In case the publication_authors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publication_authorsUpdateInput, publication_authorsUncheckedUpdateInput>
  }

  /**
   * publication_authors delete
   */
  export type publication_authorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    /**
     * Filter which publication_authors to delete.
     */
    where: publication_authorsWhereUniqueInput
  }

  /**
   * publication_authors deleteMany
   */
  export type publication_authorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_authors to delete
     */
    where?: publication_authorsWhereInput
    /**
     * Limit how many publication_authors to delete.
     */
    limit?: number
  }

  /**
   * publication_authors without action
   */
  export type publication_authorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
  }


  /**
   * Model publication_entities
   */

  export type AggregatePublication_entities = {
    _count: Publication_entitiesCountAggregateOutputType | null
    _avg: Publication_entitiesAvgAggregateOutputType | null
    _sum: Publication_entitiesSumAggregateOutputType | null
    _min: Publication_entitiesMinAggregateOutputType | null
    _max: Publication_entitiesMaxAggregateOutputType | null
  }

  export type Publication_entitiesAvgAggregateOutputType = {
    confidence: number | null
  }

  export type Publication_entitiesSumAggregateOutputType = {
    confidence: number | null
  }

  export type Publication_entitiesMinAggregateOutputType = {
    id: string | null
    publication_id: string | null
    entity_id: string | null
    confidence: number | null
    context: string | null
  }

  export type Publication_entitiesMaxAggregateOutputType = {
    id: string | null
    publication_id: string | null
    entity_id: string | null
    confidence: number | null
    context: string | null
  }

  export type Publication_entitiesCountAggregateOutputType = {
    id: number
    publication_id: number
    entity_id: number
    confidence: number
    context: number
    _all: number
  }


  export type Publication_entitiesAvgAggregateInputType = {
    confidence?: true
  }

  export type Publication_entitiesSumAggregateInputType = {
    confidence?: true
  }

  export type Publication_entitiesMinAggregateInputType = {
    id?: true
    publication_id?: true
    entity_id?: true
    confidence?: true
    context?: true
  }

  export type Publication_entitiesMaxAggregateInputType = {
    id?: true
    publication_id?: true
    entity_id?: true
    confidence?: true
    context?: true
  }

  export type Publication_entitiesCountAggregateInputType = {
    id?: true
    publication_id?: true
    entity_id?: true
    confidence?: true
    context?: true
    _all?: true
  }

  export type Publication_entitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_entities to aggregate.
     */
    where?: publication_entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_entities to fetch.
     */
    orderBy?: publication_entitiesOrderByWithRelationInput | publication_entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publication_entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publication_entities
    **/
    _count?: true | Publication_entitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Publication_entitiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Publication_entitiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Publication_entitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Publication_entitiesMaxAggregateInputType
  }

  export type GetPublication_entitiesAggregateType<T extends Publication_entitiesAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication_entities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication_entities[P]>
      : GetScalarType<T[P], AggregatePublication_entities[P]>
  }




  export type publication_entitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_entitiesWhereInput
    orderBy?: publication_entitiesOrderByWithAggregationInput | publication_entitiesOrderByWithAggregationInput[]
    by: Publication_entitiesScalarFieldEnum[] | Publication_entitiesScalarFieldEnum
    having?: publication_entitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Publication_entitiesCountAggregateInputType | true
    _avg?: Publication_entitiesAvgAggregateInputType
    _sum?: Publication_entitiesSumAggregateInputType
    _min?: Publication_entitiesMinAggregateInputType
    _max?: Publication_entitiesMaxAggregateInputType
  }

  export type Publication_entitiesGroupByOutputType = {
    id: string
    publication_id: string
    entity_id: string
    confidence: number | null
    context: string | null
    _count: Publication_entitiesCountAggregateOutputType | null
    _avg: Publication_entitiesAvgAggregateOutputType | null
    _sum: Publication_entitiesSumAggregateOutputType | null
    _min: Publication_entitiesMinAggregateOutputType | null
    _max: Publication_entitiesMaxAggregateOutputType | null
  }

  type GetPublication_entitiesGroupByPayload<T extends publication_entitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Publication_entitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Publication_entitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Publication_entitiesGroupByOutputType[P]>
            : GetScalarType<T[P], Publication_entitiesGroupByOutputType[P]>
        }
      >
    >


  export type publication_entitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publication_id?: boolean
    entity_id?: boolean
    confidence?: boolean
    context?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_entities"]>

  export type publication_entitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publication_id?: boolean
    entity_id?: boolean
    confidence?: boolean
    context?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_entities"]>

  export type publication_entitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publication_id?: boolean
    entity_id?: boolean
    confidence?: boolean
    context?: boolean
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_entities"]>

  export type publication_entitiesSelectScalar = {
    id?: boolean
    publication_id?: boolean
    entity_id?: boolean
    confidence?: boolean
    context?: boolean
  }

  export type publication_entitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publication_id" | "entity_id" | "confidence" | "context", ExtArgs["result"]["publication_entities"]>
  export type publication_entitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_entitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_entitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entities?: boolean | entitiesDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }

  export type $publication_entitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publication_entities"
    objects: {
      entities: Prisma.$entitiesPayload<ExtArgs>
      publications: Prisma.$publicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publication_id: string
      entity_id: string
      confidence: number | null
      context: string | null
    }, ExtArgs["result"]["publication_entities"]>
    composites: {}
  }

  type publication_entitiesGetPayload<S extends boolean | null | undefined | publication_entitiesDefaultArgs> = $Result.GetResult<Prisma.$publication_entitiesPayload, S>

  type publication_entitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publication_entitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Publication_entitiesCountAggregateInputType | true
    }

  export interface publication_entitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publication_entities'], meta: { name: 'publication_entities' } }
    /**
     * Find zero or one Publication_entities that matches the filter.
     * @param {publication_entitiesFindUniqueArgs} args - Arguments to find a Publication_entities
     * @example
     * // Get one Publication_entities
     * const publication_entities = await prisma.publication_entities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publication_entitiesFindUniqueArgs>(args: SelectSubset<T, publication_entitiesFindUniqueArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publication_entities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publication_entitiesFindUniqueOrThrowArgs} args - Arguments to find a Publication_entities
     * @example
     * // Get one Publication_entities
     * const publication_entities = await prisma.publication_entities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publication_entitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, publication_entitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_entitiesFindFirstArgs} args - Arguments to find a Publication_entities
     * @example
     * // Get one Publication_entities
     * const publication_entities = await prisma.publication_entities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publication_entitiesFindFirstArgs>(args?: SelectSubset<T, publication_entitiesFindFirstArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_entities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_entitiesFindFirstOrThrowArgs} args - Arguments to find a Publication_entities
     * @example
     * // Get one Publication_entities
     * const publication_entities = await prisma.publication_entities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publication_entitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, publication_entitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publication_entities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_entitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publication_entities
     * const publication_entities = await prisma.publication_entities.findMany()
     * 
     * // Get first 10 Publication_entities
     * const publication_entities = await prisma.publication_entities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publication_entitiesWithIdOnly = await prisma.publication_entities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends publication_entitiesFindManyArgs>(args?: SelectSubset<T, publication_entitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publication_entities.
     * @param {publication_entitiesCreateArgs} args - Arguments to create a Publication_entities.
     * @example
     * // Create one Publication_entities
     * const Publication_entities = await prisma.publication_entities.create({
     *   data: {
     *     // ... data to create a Publication_entities
     *   }
     * })
     * 
     */
    create<T extends publication_entitiesCreateArgs>(args: SelectSubset<T, publication_entitiesCreateArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publication_entities.
     * @param {publication_entitiesCreateManyArgs} args - Arguments to create many Publication_entities.
     * @example
     * // Create many Publication_entities
     * const publication_entities = await prisma.publication_entities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publication_entitiesCreateManyArgs>(args?: SelectSubset<T, publication_entitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publication_entities and returns the data saved in the database.
     * @param {publication_entitiesCreateManyAndReturnArgs} args - Arguments to create many Publication_entities.
     * @example
     * // Create many Publication_entities
     * const publication_entities = await prisma.publication_entities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publication_entities and only return the `id`
     * const publication_entitiesWithIdOnly = await prisma.publication_entities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publication_entitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, publication_entitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publication_entities.
     * @param {publication_entitiesDeleteArgs} args - Arguments to delete one Publication_entities.
     * @example
     * // Delete one Publication_entities
     * const Publication_entities = await prisma.publication_entities.delete({
     *   where: {
     *     // ... filter to delete one Publication_entities
     *   }
     * })
     * 
     */
    delete<T extends publication_entitiesDeleteArgs>(args: SelectSubset<T, publication_entitiesDeleteArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publication_entities.
     * @param {publication_entitiesUpdateArgs} args - Arguments to update one Publication_entities.
     * @example
     * // Update one Publication_entities
     * const publication_entities = await prisma.publication_entities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publication_entitiesUpdateArgs>(args: SelectSubset<T, publication_entitiesUpdateArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publication_entities.
     * @param {publication_entitiesDeleteManyArgs} args - Arguments to filter Publication_entities to delete.
     * @example
     * // Delete a few Publication_entities
     * const { count } = await prisma.publication_entities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publication_entitiesDeleteManyArgs>(args?: SelectSubset<T, publication_entitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_entitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publication_entities
     * const publication_entities = await prisma.publication_entities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publication_entitiesUpdateManyArgs>(args: SelectSubset<T, publication_entitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_entities and returns the data updated in the database.
     * @param {publication_entitiesUpdateManyAndReturnArgs} args - Arguments to update many Publication_entities.
     * @example
     * // Update many Publication_entities
     * const publication_entities = await prisma.publication_entities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publication_entities and only return the `id`
     * const publication_entitiesWithIdOnly = await prisma.publication_entities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publication_entitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, publication_entitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publication_entities.
     * @param {publication_entitiesUpsertArgs} args - Arguments to update or create a Publication_entities.
     * @example
     * // Update or create a Publication_entities
     * const publication_entities = await prisma.publication_entities.upsert({
     *   create: {
     *     // ... data to create a Publication_entities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication_entities we want to update
     *   }
     * })
     */
    upsert<T extends publication_entitiesUpsertArgs>(args: SelectSubset<T, publication_entitiesUpsertArgs<ExtArgs>>): Prisma__publication_entitiesClient<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publication_entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_entitiesCountArgs} args - Arguments to filter Publication_entities to count.
     * @example
     * // Count the number of Publication_entities
     * const count = await prisma.publication_entities.count({
     *   where: {
     *     // ... the filter for the Publication_entities we want to count
     *   }
     * })
    **/
    count<T extends publication_entitiesCountArgs>(
      args?: Subset<T, publication_entitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Publication_entitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication_entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publication_entitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Publication_entitiesAggregateArgs>(args: Subset<T, Publication_entitiesAggregateArgs>): Prisma.PrismaPromise<GetPublication_entitiesAggregateType<T>>

    /**
     * Group by Publication_entities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_entitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publication_entitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publication_entitiesGroupByArgs['orderBy'] }
        : { orderBy?: publication_entitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publication_entitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublication_entitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publication_entities model
   */
  readonly fields: publication_entitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publication_entities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publication_entitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entities<T extends entitiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, entitiesDefaultArgs<ExtArgs>>): Prisma__entitiesClient<$Result.GetResult<Prisma.$entitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publications<T extends publicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publicationsDefaultArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publication_entities model
   */
  interface publication_entitiesFieldRefs {
    readonly id: FieldRef<"publication_entities", 'String'>
    readonly publication_id: FieldRef<"publication_entities", 'String'>
    readonly entity_id: FieldRef<"publication_entities", 'String'>
    readonly confidence: FieldRef<"publication_entities", 'Float'>
    readonly context: FieldRef<"publication_entities", 'String'>
  }
    

  // Custom InputTypes
  /**
   * publication_entities findUnique
   */
  export type publication_entitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * Filter, which publication_entities to fetch.
     */
    where: publication_entitiesWhereUniqueInput
  }

  /**
   * publication_entities findUniqueOrThrow
   */
  export type publication_entitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * Filter, which publication_entities to fetch.
     */
    where: publication_entitiesWhereUniqueInput
  }

  /**
   * publication_entities findFirst
   */
  export type publication_entitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * Filter, which publication_entities to fetch.
     */
    where?: publication_entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_entities to fetch.
     */
    orderBy?: publication_entitiesOrderByWithRelationInput | publication_entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_entities.
     */
    cursor?: publication_entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_entities.
     */
    distinct?: Publication_entitiesScalarFieldEnum | Publication_entitiesScalarFieldEnum[]
  }

  /**
   * publication_entities findFirstOrThrow
   */
  export type publication_entitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * Filter, which publication_entities to fetch.
     */
    where?: publication_entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_entities to fetch.
     */
    orderBy?: publication_entitiesOrderByWithRelationInput | publication_entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_entities.
     */
    cursor?: publication_entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_entities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_entities.
     */
    distinct?: Publication_entitiesScalarFieldEnum | Publication_entitiesScalarFieldEnum[]
  }

  /**
   * publication_entities findMany
   */
  export type publication_entitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * Filter, which publication_entities to fetch.
     */
    where?: publication_entitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_entities to fetch.
     */
    orderBy?: publication_entitiesOrderByWithRelationInput | publication_entitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publication_entities.
     */
    cursor?: publication_entitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_entities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_entities.
     */
    skip?: number
    distinct?: Publication_entitiesScalarFieldEnum | Publication_entitiesScalarFieldEnum[]
  }

  /**
   * publication_entities create
   */
  export type publication_entitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a publication_entities.
     */
    data: XOR<publication_entitiesCreateInput, publication_entitiesUncheckedCreateInput>
  }

  /**
   * publication_entities createMany
   */
  export type publication_entitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publication_entities.
     */
    data: publication_entitiesCreateManyInput | publication_entitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publication_entities createManyAndReturn
   */
  export type publication_entitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * The data used to create many publication_entities.
     */
    data: publication_entitiesCreateManyInput | publication_entitiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_entities update
   */
  export type publication_entitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a publication_entities.
     */
    data: XOR<publication_entitiesUpdateInput, publication_entitiesUncheckedUpdateInput>
    /**
     * Choose, which publication_entities to update.
     */
    where: publication_entitiesWhereUniqueInput
  }

  /**
   * publication_entities updateMany
   */
  export type publication_entitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publication_entities.
     */
    data: XOR<publication_entitiesUpdateManyMutationInput, publication_entitiesUncheckedUpdateManyInput>
    /**
     * Filter which publication_entities to update
     */
    where?: publication_entitiesWhereInput
    /**
     * Limit how many publication_entities to update.
     */
    limit?: number
  }

  /**
   * publication_entities updateManyAndReturn
   */
  export type publication_entitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * The data used to update publication_entities.
     */
    data: XOR<publication_entitiesUpdateManyMutationInput, publication_entitiesUncheckedUpdateManyInput>
    /**
     * Filter which publication_entities to update
     */
    where?: publication_entitiesWhereInput
    /**
     * Limit how many publication_entities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_entities upsert
   */
  export type publication_entitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the publication_entities to update in case it exists.
     */
    where: publication_entitiesWhereUniqueInput
    /**
     * In case the publication_entities found by the `where` argument doesn't exist, create a new publication_entities with this data.
     */
    create: XOR<publication_entitiesCreateInput, publication_entitiesUncheckedCreateInput>
    /**
     * In case the publication_entities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publication_entitiesUpdateInput, publication_entitiesUncheckedUpdateInput>
  }

  /**
   * publication_entities delete
   */
  export type publication_entitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    /**
     * Filter which publication_entities to delete.
     */
    where: publication_entitiesWhereUniqueInput
  }

  /**
   * publication_entities deleteMany
   */
  export type publication_entitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_entities to delete
     */
    where?: publication_entitiesWhereInput
    /**
     * Limit how many publication_entities to delete.
     */
    limit?: number
  }

  /**
   * publication_entities without action
   */
  export type publication_entitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
  }


  /**
   * Model publication_keywords
   */

  export type AggregatePublication_keywords = {
    _count: Publication_keywordsCountAggregateOutputType | null
    _min: Publication_keywordsMinAggregateOutputType | null
    _max: Publication_keywordsMaxAggregateOutputType | null
  }

  export type Publication_keywordsMinAggregateOutputType = {
    publication_id: string | null
    keyword_id: string | null
  }

  export type Publication_keywordsMaxAggregateOutputType = {
    publication_id: string | null
    keyword_id: string | null
  }

  export type Publication_keywordsCountAggregateOutputType = {
    publication_id: number
    keyword_id: number
    _all: number
  }


  export type Publication_keywordsMinAggregateInputType = {
    publication_id?: true
    keyword_id?: true
  }

  export type Publication_keywordsMaxAggregateInputType = {
    publication_id?: true
    keyword_id?: true
  }

  export type Publication_keywordsCountAggregateInputType = {
    publication_id?: true
    keyword_id?: true
    _all?: true
  }

  export type Publication_keywordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_keywords to aggregate.
     */
    where?: publication_keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_keywords to fetch.
     */
    orderBy?: publication_keywordsOrderByWithRelationInput | publication_keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publication_keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publication_keywords
    **/
    _count?: true | Publication_keywordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Publication_keywordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Publication_keywordsMaxAggregateInputType
  }

  export type GetPublication_keywordsAggregateType<T extends Publication_keywordsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication_keywords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication_keywords[P]>
      : GetScalarType<T[P], AggregatePublication_keywords[P]>
  }




  export type publication_keywordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_keywordsWhereInput
    orderBy?: publication_keywordsOrderByWithAggregationInput | publication_keywordsOrderByWithAggregationInput[]
    by: Publication_keywordsScalarFieldEnum[] | Publication_keywordsScalarFieldEnum
    having?: publication_keywordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Publication_keywordsCountAggregateInputType | true
    _min?: Publication_keywordsMinAggregateInputType
    _max?: Publication_keywordsMaxAggregateInputType
  }

  export type Publication_keywordsGroupByOutputType = {
    publication_id: string
    keyword_id: string
    _count: Publication_keywordsCountAggregateOutputType | null
    _min: Publication_keywordsMinAggregateOutputType | null
    _max: Publication_keywordsMaxAggregateOutputType | null
  }

  type GetPublication_keywordsGroupByPayload<T extends publication_keywordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Publication_keywordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Publication_keywordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Publication_keywordsGroupByOutputType[P]>
            : GetScalarType<T[P], Publication_keywordsGroupByOutputType[P]>
        }
      >
    >


  export type publication_keywordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    keyword_id?: boolean
    keywords?: boolean | keywordsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_keywords"]>

  export type publication_keywordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    keyword_id?: boolean
    keywords?: boolean | keywordsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_keywords"]>

  export type publication_keywordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    keyword_id?: boolean
    keywords?: boolean | keywordsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_keywords"]>

  export type publication_keywordsSelectScalar = {
    publication_id?: boolean
    keyword_id?: boolean
  }

  export type publication_keywordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"publication_id" | "keyword_id", ExtArgs["result"]["publication_keywords"]>
  export type publication_keywordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | keywordsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_keywordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | keywordsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_keywordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    keywords?: boolean | keywordsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }

  export type $publication_keywordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publication_keywords"
    objects: {
      keywords: Prisma.$keywordsPayload<ExtArgs>
      publications: Prisma.$publicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      publication_id: string
      keyword_id: string
    }, ExtArgs["result"]["publication_keywords"]>
    composites: {}
  }

  type publication_keywordsGetPayload<S extends boolean | null | undefined | publication_keywordsDefaultArgs> = $Result.GetResult<Prisma.$publication_keywordsPayload, S>

  type publication_keywordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publication_keywordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Publication_keywordsCountAggregateInputType | true
    }

  export interface publication_keywordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publication_keywords'], meta: { name: 'publication_keywords' } }
    /**
     * Find zero or one Publication_keywords that matches the filter.
     * @param {publication_keywordsFindUniqueArgs} args - Arguments to find a Publication_keywords
     * @example
     * // Get one Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publication_keywordsFindUniqueArgs>(args: SelectSubset<T, publication_keywordsFindUniqueArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publication_keywords that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publication_keywordsFindUniqueOrThrowArgs} args - Arguments to find a Publication_keywords
     * @example
     * // Get one Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publication_keywordsFindUniqueOrThrowArgs>(args: SelectSubset<T, publication_keywordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_keywordsFindFirstArgs} args - Arguments to find a Publication_keywords
     * @example
     * // Get one Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publication_keywordsFindFirstArgs>(args?: SelectSubset<T, publication_keywordsFindFirstArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_keywords that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_keywordsFindFirstOrThrowArgs} args - Arguments to find a Publication_keywords
     * @example
     * // Get one Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publication_keywordsFindFirstOrThrowArgs>(args?: SelectSubset<T, publication_keywordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publication_keywords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_keywordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.findMany()
     * 
     * // Get first 10 Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.findMany({ take: 10 })
     * 
     * // Only select the `publication_id`
     * const publication_keywordsWithPublication_idOnly = await prisma.publication_keywords.findMany({ select: { publication_id: true } })
     * 
     */
    findMany<T extends publication_keywordsFindManyArgs>(args?: SelectSubset<T, publication_keywordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publication_keywords.
     * @param {publication_keywordsCreateArgs} args - Arguments to create a Publication_keywords.
     * @example
     * // Create one Publication_keywords
     * const Publication_keywords = await prisma.publication_keywords.create({
     *   data: {
     *     // ... data to create a Publication_keywords
     *   }
     * })
     * 
     */
    create<T extends publication_keywordsCreateArgs>(args: SelectSubset<T, publication_keywordsCreateArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publication_keywords.
     * @param {publication_keywordsCreateManyArgs} args - Arguments to create many Publication_keywords.
     * @example
     * // Create many Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publication_keywordsCreateManyArgs>(args?: SelectSubset<T, publication_keywordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publication_keywords and returns the data saved in the database.
     * @param {publication_keywordsCreateManyAndReturnArgs} args - Arguments to create many Publication_keywords.
     * @example
     * // Create many Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publication_keywords and only return the `publication_id`
     * const publication_keywordsWithPublication_idOnly = await prisma.publication_keywords.createManyAndReturn({
     *   select: { publication_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publication_keywordsCreateManyAndReturnArgs>(args?: SelectSubset<T, publication_keywordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publication_keywords.
     * @param {publication_keywordsDeleteArgs} args - Arguments to delete one Publication_keywords.
     * @example
     * // Delete one Publication_keywords
     * const Publication_keywords = await prisma.publication_keywords.delete({
     *   where: {
     *     // ... filter to delete one Publication_keywords
     *   }
     * })
     * 
     */
    delete<T extends publication_keywordsDeleteArgs>(args: SelectSubset<T, publication_keywordsDeleteArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publication_keywords.
     * @param {publication_keywordsUpdateArgs} args - Arguments to update one Publication_keywords.
     * @example
     * // Update one Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publication_keywordsUpdateArgs>(args: SelectSubset<T, publication_keywordsUpdateArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publication_keywords.
     * @param {publication_keywordsDeleteManyArgs} args - Arguments to filter Publication_keywords to delete.
     * @example
     * // Delete a few Publication_keywords
     * const { count } = await prisma.publication_keywords.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publication_keywordsDeleteManyArgs>(args?: SelectSubset<T, publication_keywordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_keywordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publication_keywordsUpdateManyArgs>(args: SelectSubset<T, publication_keywordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_keywords and returns the data updated in the database.
     * @param {publication_keywordsUpdateManyAndReturnArgs} args - Arguments to update many Publication_keywords.
     * @example
     * // Update many Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publication_keywords and only return the `publication_id`
     * const publication_keywordsWithPublication_idOnly = await prisma.publication_keywords.updateManyAndReturn({
     *   select: { publication_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publication_keywordsUpdateManyAndReturnArgs>(args: SelectSubset<T, publication_keywordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publication_keywords.
     * @param {publication_keywordsUpsertArgs} args - Arguments to update or create a Publication_keywords.
     * @example
     * // Update or create a Publication_keywords
     * const publication_keywords = await prisma.publication_keywords.upsert({
     *   create: {
     *     // ... data to create a Publication_keywords
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication_keywords we want to update
     *   }
     * })
     */
    upsert<T extends publication_keywordsUpsertArgs>(args: SelectSubset<T, publication_keywordsUpsertArgs<ExtArgs>>): Prisma__publication_keywordsClient<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publication_keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_keywordsCountArgs} args - Arguments to filter Publication_keywords to count.
     * @example
     * // Count the number of Publication_keywords
     * const count = await prisma.publication_keywords.count({
     *   where: {
     *     // ... the filter for the Publication_keywords we want to count
     *   }
     * })
    **/
    count<T extends publication_keywordsCountArgs>(
      args?: Subset<T, publication_keywordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Publication_keywordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication_keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publication_keywordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Publication_keywordsAggregateArgs>(args: Subset<T, Publication_keywordsAggregateArgs>): Prisma.PrismaPromise<GetPublication_keywordsAggregateType<T>>

    /**
     * Group by Publication_keywords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_keywordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publication_keywordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publication_keywordsGroupByArgs['orderBy'] }
        : { orderBy?: publication_keywordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publication_keywordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublication_keywordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publication_keywords model
   */
  readonly fields: publication_keywordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publication_keywords.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publication_keywordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    keywords<T extends keywordsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, keywordsDefaultArgs<ExtArgs>>): Prisma__keywordsClient<$Result.GetResult<Prisma.$keywordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publications<T extends publicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publicationsDefaultArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publication_keywords model
   */
  interface publication_keywordsFieldRefs {
    readonly publication_id: FieldRef<"publication_keywords", 'String'>
    readonly keyword_id: FieldRef<"publication_keywords", 'String'>
  }
    

  // Custom InputTypes
  /**
   * publication_keywords findUnique
   */
  export type publication_keywordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * Filter, which publication_keywords to fetch.
     */
    where: publication_keywordsWhereUniqueInput
  }

  /**
   * publication_keywords findUniqueOrThrow
   */
  export type publication_keywordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * Filter, which publication_keywords to fetch.
     */
    where: publication_keywordsWhereUniqueInput
  }

  /**
   * publication_keywords findFirst
   */
  export type publication_keywordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * Filter, which publication_keywords to fetch.
     */
    where?: publication_keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_keywords to fetch.
     */
    orderBy?: publication_keywordsOrderByWithRelationInput | publication_keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_keywords.
     */
    cursor?: publication_keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_keywords.
     */
    distinct?: Publication_keywordsScalarFieldEnum | Publication_keywordsScalarFieldEnum[]
  }

  /**
   * publication_keywords findFirstOrThrow
   */
  export type publication_keywordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * Filter, which publication_keywords to fetch.
     */
    where?: publication_keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_keywords to fetch.
     */
    orderBy?: publication_keywordsOrderByWithRelationInput | publication_keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_keywords.
     */
    cursor?: publication_keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_keywords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_keywords.
     */
    distinct?: Publication_keywordsScalarFieldEnum | Publication_keywordsScalarFieldEnum[]
  }

  /**
   * publication_keywords findMany
   */
  export type publication_keywordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * Filter, which publication_keywords to fetch.
     */
    where?: publication_keywordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_keywords to fetch.
     */
    orderBy?: publication_keywordsOrderByWithRelationInput | publication_keywordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publication_keywords.
     */
    cursor?: publication_keywordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_keywords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_keywords.
     */
    skip?: number
    distinct?: Publication_keywordsScalarFieldEnum | Publication_keywordsScalarFieldEnum[]
  }

  /**
   * publication_keywords create
   */
  export type publication_keywordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * The data needed to create a publication_keywords.
     */
    data: XOR<publication_keywordsCreateInput, publication_keywordsUncheckedCreateInput>
  }

  /**
   * publication_keywords createMany
   */
  export type publication_keywordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publication_keywords.
     */
    data: publication_keywordsCreateManyInput | publication_keywordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publication_keywords createManyAndReturn
   */
  export type publication_keywordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * The data used to create many publication_keywords.
     */
    data: publication_keywordsCreateManyInput | publication_keywordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_keywords update
   */
  export type publication_keywordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * The data needed to update a publication_keywords.
     */
    data: XOR<publication_keywordsUpdateInput, publication_keywordsUncheckedUpdateInput>
    /**
     * Choose, which publication_keywords to update.
     */
    where: publication_keywordsWhereUniqueInput
  }

  /**
   * publication_keywords updateMany
   */
  export type publication_keywordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publication_keywords.
     */
    data: XOR<publication_keywordsUpdateManyMutationInput, publication_keywordsUncheckedUpdateManyInput>
    /**
     * Filter which publication_keywords to update
     */
    where?: publication_keywordsWhereInput
    /**
     * Limit how many publication_keywords to update.
     */
    limit?: number
  }

  /**
   * publication_keywords updateManyAndReturn
   */
  export type publication_keywordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * The data used to update publication_keywords.
     */
    data: XOR<publication_keywordsUpdateManyMutationInput, publication_keywordsUncheckedUpdateManyInput>
    /**
     * Filter which publication_keywords to update
     */
    where?: publication_keywordsWhereInput
    /**
     * Limit how many publication_keywords to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_keywords upsert
   */
  export type publication_keywordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * The filter to search for the publication_keywords to update in case it exists.
     */
    where: publication_keywordsWhereUniqueInput
    /**
     * In case the publication_keywords found by the `where` argument doesn't exist, create a new publication_keywords with this data.
     */
    create: XOR<publication_keywordsCreateInput, publication_keywordsUncheckedCreateInput>
    /**
     * In case the publication_keywords was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publication_keywordsUpdateInput, publication_keywordsUncheckedUpdateInput>
  }

  /**
   * publication_keywords delete
   */
  export type publication_keywordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    /**
     * Filter which publication_keywords to delete.
     */
    where: publication_keywordsWhereUniqueInput
  }

  /**
   * publication_keywords deleteMany
   */
  export type publication_keywordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_keywords to delete
     */
    where?: publication_keywordsWhereInput
    /**
     * Limit how many publication_keywords to delete.
     */
    limit?: number
  }

  /**
   * publication_keywords without action
   */
  export type publication_keywordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
  }


  /**
   * Model publication_mesh_terms
   */

  export type AggregatePublication_mesh_terms = {
    _count: Publication_mesh_termsCountAggregateOutputType | null
    _min: Publication_mesh_termsMinAggregateOutputType | null
    _max: Publication_mesh_termsMaxAggregateOutputType | null
  }

  export type Publication_mesh_termsMinAggregateOutputType = {
    publication_id: string | null
    mesh_term_id: string | null
    is_major_topic: boolean | null
  }

  export type Publication_mesh_termsMaxAggregateOutputType = {
    publication_id: string | null
    mesh_term_id: string | null
    is_major_topic: boolean | null
  }

  export type Publication_mesh_termsCountAggregateOutputType = {
    publication_id: number
    mesh_term_id: number
    is_major_topic: number
    _all: number
  }


  export type Publication_mesh_termsMinAggregateInputType = {
    publication_id?: true
    mesh_term_id?: true
    is_major_topic?: true
  }

  export type Publication_mesh_termsMaxAggregateInputType = {
    publication_id?: true
    mesh_term_id?: true
    is_major_topic?: true
  }

  export type Publication_mesh_termsCountAggregateInputType = {
    publication_id?: true
    mesh_term_id?: true
    is_major_topic?: true
    _all?: true
  }

  export type Publication_mesh_termsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_mesh_terms to aggregate.
     */
    where?: publication_mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_mesh_terms to fetch.
     */
    orderBy?: publication_mesh_termsOrderByWithRelationInput | publication_mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publication_mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_mesh_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publication_mesh_terms
    **/
    _count?: true | Publication_mesh_termsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Publication_mesh_termsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Publication_mesh_termsMaxAggregateInputType
  }

  export type GetPublication_mesh_termsAggregateType<T extends Publication_mesh_termsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublication_mesh_terms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublication_mesh_terms[P]>
      : GetScalarType<T[P], AggregatePublication_mesh_terms[P]>
  }




  export type publication_mesh_termsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publication_mesh_termsWhereInput
    orderBy?: publication_mesh_termsOrderByWithAggregationInput | publication_mesh_termsOrderByWithAggregationInput[]
    by: Publication_mesh_termsScalarFieldEnum[] | Publication_mesh_termsScalarFieldEnum
    having?: publication_mesh_termsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Publication_mesh_termsCountAggregateInputType | true
    _min?: Publication_mesh_termsMinAggregateInputType
    _max?: Publication_mesh_termsMaxAggregateInputType
  }

  export type Publication_mesh_termsGroupByOutputType = {
    publication_id: string
    mesh_term_id: string
    is_major_topic: boolean
    _count: Publication_mesh_termsCountAggregateOutputType | null
    _min: Publication_mesh_termsMinAggregateOutputType | null
    _max: Publication_mesh_termsMaxAggregateOutputType | null
  }

  type GetPublication_mesh_termsGroupByPayload<T extends publication_mesh_termsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Publication_mesh_termsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Publication_mesh_termsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Publication_mesh_termsGroupByOutputType[P]>
            : GetScalarType<T[P], Publication_mesh_termsGroupByOutputType[P]>
        }
      >
    >


  export type publication_mesh_termsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    mesh_term_id?: boolean
    is_major_topic?: boolean
    mesh_terms?: boolean | mesh_termsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_mesh_terms"]>

  export type publication_mesh_termsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    mesh_term_id?: boolean
    is_major_topic?: boolean
    mesh_terms?: boolean | mesh_termsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_mesh_terms"]>

  export type publication_mesh_termsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    publication_id?: boolean
    mesh_term_id?: boolean
    is_major_topic?: boolean
    mesh_terms?: boolean | mesh_termsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publication_mesh_terms"]>

  export type publication_mesh_termsSelectScalar = {
    publication_id?: boolean
    mesh_term_id?: boolean
    is_major_topic?: boolean
  }

  export type publication_mesh_termsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"publication_id" | "mesh_term_id" | "is_major_topic", ExtArgs["result"]["publication_mesh_terms"]>
  export type publication_mesh_termsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mesh_terms?: boolean | mesh_termsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_mesh_termsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mesh_terms?: boolean | mesh_termsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type publication_mesh_termsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    mesh_terms?: boolean | mesh_termsDefaultArgs<ExtArgs>
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }

  export type $publication_mesh_termsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publication_mesh_terms"
    objects: {
      mesh_terms: Prisma.$mesh_termsPayload<ExtArgs>
      publications: Prisma.$publicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      publication_id: string
      mesh_term_id: string
      is_major_topic: boolean
    }, ExtArgs["result"]["publication_mesh_terms"]>
    composites: {}
  }

  type publication_mesh_termsGetPayload<S extends boolean | null | undefined | publication_mesh_termsDefaultArgs> = $Result.GetResult<Prisma.$publication_mesh_termsPayload, S>

  type publication_mesh_termsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publication_mesh_termsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Publication_mesh_termsCountAggregateInputType | true
    }

  export interface publication_mesh_termsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publication_mesh_terms'], meta: { name: 'publication_mesh_terms' } }
    /**
     * Find zero or one Publication_mesh_terms that matches the filter.
     * @param {publication_mesh_termsFindUniqueArgs} args - Arguments to find a Publication_mesh_terms
     * @example
     * // Get one Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publication_mesh_termsFindUniqueArgs>(args: SelectSubset<T, publication_mesh_termsFindUniqueArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publication_mesh_terms that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publication_mesh_termsFindUniqueOrThrowArgs} args - Arguments to find a Publication_mesh_terms
     * @example
     * // Get one Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publication_mesh_termsFindUniqueOrThrowArgs>(args: SelectSubset<T, publication_mesh_termsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_mesh_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_mesh_termsFindFirstArgs} args - Arguments to find a Publication_mesh_terms
     * @example
     * // Get one Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publication_mesh_termsFindFirstArgs>(args?: SelectSubset<T, publication_mesh_termsFindFirstArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publication_mesh_terms that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_mesh_termsFindFirstOrThrowArgs} args - Arguments to find a Publication_mesh_terms
     * @example
     * // Get one Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publication_mesh_termsFindFirstOrThrowArgs>(args?: SelectSubset<T, publication_mesh_termsFindFirstOrThrowArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publication_mesh_terms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_mesh_termsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.findMany()
     * 
     * // Get first 10 Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.findMany({ take: 10 })
     * 
     * // Only select the `publication_id`
     * const publication_mesh_termsWithPublication_idOnly = await prisma.publication_mesh_terms.findMany({ select: { publication_id: true } })
     * 
     */
    findMany<T extends publication_mesh_termsFindManyArgs>(args?: SelectSubset<T, publication_mesh_termsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publication_mesh_terms.
     * @param {publication_mesh_termsCreateArgs} args - Arguments to create a Publication_mesh_terms.
     * @example
     * // Create one Publication_mesh_terms
     * const Publication_mesh_terms = await prisma.publication_mesh_terms.create({
     *   data: {
     *     // ... data to create a Publication_mesh_terms
     *   }
     * })
     * 
     */
    create<T extends publication_mesh_termsCreateArgs>(args: SelectSubset<T, publication_mesh_termsCreateArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publication_mesh_terms.
     * @param {publication_mesh_termsCreateManyArgs} args - Arguments to create many Publication_mesh_terms.
     * @example
     * // Create many Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publication_mesh_termsCreateManyArgs>(args?: SelectSubset<T, publication_mesh_termsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publication_mesh_terms and returns the data saved in the database.
     * @param {publication_mesh_termsCreateManyAndReturnArgs} args - Arguments to create many Publication_mesh_terms.
     * @example
     * // Create many Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publication_mesh_terms and only return the `publication_id`
     * const publication_mesh_termsWithPublication_idOnly = await prisma.publication_mesh_terms.createManyAndReturn({
     *   select: { publication_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publication_mesh_termsCreateManyAndReturnArgs>(args?: SelectSubset<T, publication_mesh_termsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publication_mesh_terms.
     * @param {publication_mesh_termsDeleteArgs} args - Arguments to delete one Publication_mesh_terms.
     * @example
     * // Delete one Publication_mesh_terms
     * const Publication_mesh_terms = await prisma.publication_mesh_terms.delete({
     *   where: {
     *     // ... filter to delete one Publication_mesh_terms
     *   }
     * })
     * 
     */
    delete<T extends publication_mesh_termsDeleteArgs>(args: SelectSubset<T, publication_mesh_termsDeleteArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publication_mesh_terms.
     * @param {publication_mesh_termsUpdateArgs} args - Arguments to update one Publication_mesh_terms.
     * @example
     * // Update one Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publication_mesh_termsUpdateArgs>(args: SelectSubset<T, publication_mesh_termsUpdateArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publication_mesh_terms.
     * @param {publication_mesh_termsDeleteManyArgs} args - Arguments to filter Publication_mesh_terms to delete.
     * @example
     * // Delete a few Publication_mesh_terms
     * const { count } = await prisma.publication_mesh_terms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publication_mesh_termsDeleteManyArgs>(args?: SelectSubset<T, publication_mesh_termsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_mesh_termsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publication_mesh_termsUpdateManyArgs>(args: SelectSubset<T, publication_mesh_termsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publication_mesh_terms and returns the data updated in the database.
     * @param {publication_mesh_termsUpdateManyAndReturnArgs} args - Arguments to update many Publication_mesh_terms.
     * @example
     * // Update many Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publication_mesh_terms and only return the `publication_id`
     * const publication_mesh_termsWithPublication_idOnly = await prisma.publication_mesh_terms.updateManyAndReturn({
     *   select: { publication_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publication_mesh_termsUpdateManyAndReturnArgs>(args: SelectSubset<T, publication_mesh_termsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publication_mesh_terms.
     * @param {publication_mesh_termsUpsertArgs} args - Arguments to update or create a Publication_mesh_terms.
     * @example
     * // Update or create a Publication_mesh_terms
     * const publication_mesh_terms = await prisma.publication_mesh_terms.upsert({
     *   create: {
     *     // ... data to create a Publication_mesh_terms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publication_mesh_terms we want to update
     *   }
     * })
     */
    upsert<T extends publication_mesh_termsUpsertArgs>(args: SelectSubset<T, publication_mesh_termsUpsertArgs<ExtArgs>>): Prisma__publication_mesh_termsClient<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publication_mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_mesh_termsCountArgs} args - Arguments to filter Publication_mesh_terms to count.
     * @example
     * // Count the number of Publication_mesh_terms
     * const count = await prisma.publication_mesh_terms.count({
     *   where: {
     *     // ... the filter for the Publication_mesh_terms we want to count
     *   }
     * })
    **/
    count<T extends publication_mesh_termsCountArgs>(
      args?: Subset<T, publication_mesh_termsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Publication_mesh_termsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publication_mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Publication_mesh_termsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Publication_mesh_termsAggregateArgs>(args: Subset<T, Publication_mesh_termsAggregateArgs>): Prisma.PrismaPromise<GetPublication_mesh_termsAggregateType<T>>

    /**
     * Group by Publication_mesh_terms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publication_mesh_termsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publication_mesh_termsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publication_mesh_termsGroupByArgs['orderBy'] }
        : { orderBy?: publication_mesh_termsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publication_mesh_termsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublication_mesh_termsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publication_mesh_terms model
   */
  readonly fields: publication_mesh_termsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publication_mesh_terms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publication_mesh_termsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    mesh_terms<T extends mesh_termsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, mesh_termsDefaultArgs<ExtArgs>>): Prisma__mesh_termsClient<$Result.GetResult<Prisma.$mesh_termsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    publications<T extends publicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publicationsDefaultArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publication_mesh_terms model
   */
  interface publication_mesh_termsFieldRefs {
    readonly publication_id: FieldRef<"publication_mesh_terms", 'String'>
    readonly mesh_term_id: FieldRef<"publication_mesh_terms", 'String'>
    readonly is_major_topic: FieldRef<"publication_mesh_terms", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * publication_mesh_terms findUnique
   */
  export type publication_mesh_termsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which publication_mesh_terms to fetch.
     */
    where: publication_mesh_termsWhereUniqueInput
  }

  /**
   * publication_mesh_terms findUniqueOrThrow
   */
  export type publication_mesh_termsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which publication_mesh_terms to fetch.
     */
    where: publication_mesh_termsWhereUniqueInput
  }

  /**
   * publication_mesh_terms findFirst
   */
  export type publication_mesh_termsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which publication_mesh_terms to fetch.
     */
    where?: publication_mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_mesh_terms to fetch.
     */
    orderBy?: publication_mesh_termsOrderByWithRelationInput | publication_mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_mesh_terms.
     */
    cursor?: publication_mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_mesh_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_mesh_terms.
     */
    distinct?: Publication_mesh_termsScalarFieldEnum | Publication_mesh_termsScalarFieldEnum[]
  }

  /**
   * publication_mesh_terms findFirstOrThrow
   */
  export type publication_mesh_termsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which publication_mesh_terms to fetch.
     */
    where?: publication_mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_mesh_terms to fetch.
     */
    orderBy?: publication_mesh_termsOrderByWithRelationInput | publication_mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publication_mesh_terms.
     */
    cursor?: publication_mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_mesh_terms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publication_mesh_terms.
     */
    distinct?: Publication_mesh_termsScalarFieldEnum | Publication_mesh_termsScalarFieldEnum[]
  }

  /**
   * publication_mesh_terms findMany
   */
  export type publication_mesh_termsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * Filter, which publication_mesh_terms to fetch.
     */
    where?: publication_mesh_termsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publication_mesh_terms to fetch.
     */
    orderBy?: publication_mesh_termsOrderByWithRelationInput | publication_mesh_termsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publication_mesh_terms.
     */
    cursor?: publication_mesh_termsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publication_mesh_terms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publication_mesh_terms.
     */
    skip?: number
    distinct?: Publication_mesh_termsScalarFieldEnum | Publication_mesh_termsScalarFieldEnum[]
  }

  /**
   * publication_mesh_terms create
   */
  export type publication_mesh_termsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * The data needed to create a publication_mesh_terms.
     */
    data: XOR<publication_mesh_termsCreateInput, publication_mesh_termsUncheckedCreateInput>
  }

  /**
   * publication_mesh_terms createMany
   */
  export type publication_mesh_termsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publication_mesh_terms.
     */
    data: publication_mesh_termsCreateManyInput | publication_mesh_termsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publication_mesh_terms createManyAndReturn
   */
  export type publication_mesh_termsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * The data used to create many publication_mesh_terms.
     */
    data: publication_mesh_termsCreateManyInput | publication_mesh_termsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_mesh_terms update
   */
  export type publication_mesh_termsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * The data needed to update a publication_mesh_terms.
     */
    data: XOR<publication_mesh_termsUpdateInput, publication_mesh_termsUncheckedUpdateInput>
    /**
     * Choose, which publication_mesh_terms to update.
     */
    where: publication_mesh_termsWhereUniqueInput
  }

  /**
   * publication_mesh_terms updateMany
   */
  export type publication_mesh_termsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publication_mesh_terms.
     */
    data: XOR<publication_mesh_termsUpdateManyMutationInput, publication_mesh_termsUncheckedUpdateManyInput>
    /**
     * Filter which publication_mesh_terms to update
     */
    where?: publication_mesh_termsWhereInput
    /**
     * Limit how many publication_mesh_terms to update.
     */
    limit?: number
  }

  /**
   * publication_mesh_terms updateManyAndReturn
   */
  export type publication_mesh_termsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * The data used to update publication_mesh_terms.
     */
    data: XOR<publication_mesh_termsUpdateManyMutationInput, publication_mesh_termsUncheckedUpdateManyInput>
    /**
     * Filter which publication_mesh_terms to update
     */
    where?: publication_mesh_termsWhereInput
    /**
     * Limit how many publication_mesh_terms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * publication_mesh_terms upsert
   */
  export type publication_mesh_termsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * The filter to search for the publication_mesh_terms to update in case it exists.
     */
    where: publication_mesh_termsWhereUniqueInput
    /**
     * In case the publication_mesh_terms found by the `where` argument doesn't exist, create a new publication_mesh_terms with this data.
     */
    create: XOR<publication_mesh_termsCreateInput, publication_mesh_termsUncheckedCreateInput>
    /**
     * In case the publication_mesh_terms was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publication_mesh_termsUpdateInput, publication_mesh_termsUncheckedUpdateInput>
  }

  /**
   * publication_mesh_terms delete
   */
  export type publication_mesh_termsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    /**
     * Filter which publication_mesh_terms to delete.
     */
    where: publication_mesh_termsWhereUniqueInput
  }

  /**
   * publication_mesh_terms deleteMany
   */
  export type publication_mesh_termsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publication_mesh_terms to delete
     */
    where?: publication_mesh_termsWhereInput
    /**
     * Limit how many publication_mesh_terms to delete.
     */
    limit?: number
  }

  /**
   * publication_mesh_terms without action
   */
  export type publication_mesh_termsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
  }


  /**
   * Model publications
   */

  export type AggregatePublications = {
    _count: PublicationsCountAggregateOutputType | null
    _min: PublicationsMinAggregateOutputType | null
    _max: PublicationsMaxAggregateOutputType | null
  }

  export type PublicationsMinAggregateOutputType = {
    id: string | null
    pmcid: string | null
    pmid: string | null
    doi: string | null
    title: string | null
    abstract: string | null
    publication_date: Date | null
    journal: string | null
    created_at: Date | null
    updated_at: Date | null
    abstract_generated: string | null
    generation_type: string | null
    key_findings: string | null
    methodology: string | null
    full_text_content: string | null
  }

  export type PublicationsMaxAggregateOutputType = {
    id: string | null
    pmcid: string | null
    pmid: string | null
    doi: string | null
    title: string | null
    abstract: string | null
    publication_date: Date | null
    journal: string | null
    created_at: Date | null
    updated_at: Date | null
    abstract_generated: string | null
    generation_type: string | null
    key_findings: string | null
    methodology: string | null
    full_text_content: string | null
  }

  export type PublicationsCountAggregateOutputType = {
    id: number
    pmcid: number
    pmid: number
    doi: number
    title: number
    abstract: number
    publication_date: number
    journal: number
    created_at: number
    updated_at: number
    abstract_generated: number
    generation_type: number
    key_findings: number
    methodology: number
    full_text_content: number
    _all: number
  }


  export type PublicationsMinAggregateInputType = {
    id?: true
    pmcid?: true
    pmid?: true
    doi?: true
    title?: true
    abstract?: true
    publication_date?: true
    journal?: true
    created_at?: true
    updated_at?: true
    abstract_generated?: true
    generation_type?: true
    key_findings?: true
    methodology?: true
    full_text_content?: true
  }

  export type PublicationsMaxAggregateInputType = {
    id?: true
    pmcid?: true
    pmid?: true
    doi?: true
    title?: true
    abstract?: true
    publication_date?: true
    journal?: true
    created_at?: true
    updated_at?: true
    abstract_generated?: true
    generation_type?: true
    key_findings?: true
    methodology?: true
    full_text_content?: true
  }

  export type PublicationsCountAggregateInputType = {
    id?: true
    pmcid?: true
    pmid?: true
    doi?: true
    title?: true
    abstract?: true
    publication_date?: true
    journal?: true
    created_at?: true
    updated_at?: true
    abstract_generated?: true
    generation_type?: true
    key_findings?: true
    methodology?: true
    full_text_content?: true
    _all?: true
  }

  export type PublicationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publications to aggregate.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned publications
    **/
    _count?: true | PublicationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PublicationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PublicationsMaxAggregateInputType
  }

  export type GetPublicationsAggregateType<T extends PublicationsAggregateArgs> = {
        [P in keyof T & keyof AggregatePublications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePublications[P]>
      : GetScalarType<T[P], AggregatePublications[P]>
  }




  export type publicationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: publicationsWhereInput
    orderBy?: publicationsOrderByWithAggregationInput | publicationsOrderByWithAggregationInput[]
    by: PublicationsScalarFieldEnum[] | PublicationsScalarFieldEnum
    having?: publicationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PublicationsCountAggregateInputType | true
    _min?: PublicationsMinAggregateInputType
    _max?: PublicationsMaxAggregateInputType
  }

  export type PublicationsGroupByOutputType = {
    id: string
    pmcid: string
    pmid: string | null
    doi: string | null
    title: string
    abstract: string | null
    publication_date: Date | null
    journal: string | null
    created_at: Date
    updated_at: Date
    abstract_generated: string | null
    generation_type: string | null
    key_findings: string | null
    methodology: string | null
    full_text_content: string | null
    _count: PublicationsCountAggregateOutputType | null
    _min: PublicationsMinAggregateOutputType | null
    _max: PublicationsMaxAggregateOutputType | null
  }

  type GetPublicationsGroupByPayload<T extends publicationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PublicationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PublicationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PublicationsGroupByOutputType[P]>
            : GetScalarType<T[P], PublicationsGroupByOutputType[P]>
        }
      >
    >


  export type publicationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pmcid?: boolean
    pmid?: boolean
    doi?: boolean
    title?: boolean
    abstract?: boolean
    publication_date?: boolean
    journal?: boolean
    created_at?: boolean
    updated_at?: boolean
    abstract_generated?: boolean
    generation_type?: boolean
    key_findings?: boolean
    methodology?: boolean
    full_text_content?: boolean
    publication_authors?: boolean | publications$publication_authorsArgs<ExtArgs>
    publication_entities?: boolean | publications$publication_entitiesArgs<ExtArgs>
    publication_keywords?: boolean | publications$publication_keywordsArgs<ExtArgs>
    publication_mesh_terms?: boolean | publications$publication_mesh_termsArgs<ExtArgs>
    text_sections?: boolean | publications$text_sectionsArgs<ExtArgs>
    _count?: boolean | PublicationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["publications"]>

  export type publicationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pmcid?: boolean
    pmid?: boolean
    doi?: boolean
    title?: boolean
    abstract?: boolean
    publication_date?: boolean
    journal?: boolean
    created_at?: boolean
    updated_at?: boolean
    abstract_generated?: boolean
    generation_type?: boolean
    key_findings?: boolean
    methodology?: boolean
    full_text_content?: boolean
  }, ExtArgs["result"]["publications"]>

  export type publicationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pmcid?: boolean
    pmid?: boolean
    doi?: boolean
    title?: boolean
    abstract?: boolean
    publication_date?: boolean
    journal?: boolean
    created_at?: boolean
    updated_at?: boolean
    abstract_generated?: boolean
    generation_type?: boolean
    key_findings?: boolean
    methodology?: boolean
    full_text_content?: boolean
  }, ExtArgs["result"]["publications"]>

  export type publicationsSelectScalar = {
    id?: boolean
    pmcid?: boolean
    pmid?: boolean
    doi?: boolean
    title?: boolean
    abstract?: boolean
    publication_date?: boolean
    journal?: boolean
    created_at?: boolean
    updated_at?: boolean
    abstract_generated?: boolean
    generation_type?: boolean
    key_findings?: boolean
    methodology?: boolean
    full_text_content?: boolean
  }

  export type publicationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pmcid" | "pmid" | "doi" | "title" | "abstract" | "publication_date" | "journal" | "created_at" | "updated_at" | "abstract_generated" | "generation_type" | "key_findings" | "methodology" | "full_text_content", ExtArgs["result"]["publications"]>
  export type publicationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publication_authors?: boolean | publications$publication_authorsArgs<ExtArgs>
    publication_entities?: boolean | publications$publication_entitiesArgs<ExtArgs>
    publication_keywords?: boolean | publications$publication_keywordsArgs<ExtArgs>
    publication_mesh_terms?: boolean | publications$publication_mesh_termsArgs<ExtArgs>
    text_sections?: boolean | publications$text_sectionsArgs<ExtArgs>
    _count?: boolean | PublicationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type publicationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type publicationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $publicationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "publications"
    objects: {
      publication_authors: Prisma.$publication_authorsPayload<ExtArgs>[]
      publication_entities: Prisma.$publication_entitiesPayload<ExtArgs>[]
      publication_keywords: Prisma.$publication_keywordsPayload<ExtArgs>[]
      publication_mesh_terms: Prisma.$publication_mesh_termsPayload<ExtArgs>[]
      text_sections: Prisma.$text_sectionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pmcid: string
      pmid: string | null
      doi: string | null
      title: string
      abstract: string | null
      publication_date: Date | null
      journal: string | null
      created_at: Date
      updated_at: Date
      abstract_generated: string | null
      generation_type: string | null
      key_findings: string | null
      methodology: string | null
      full_text_content: string | null
    }, ExtArgs["result"]["publications"]>
    composites: {}
  }

  type publicationsGetPayload<S extends boolean | null | undefined | publicationsDefaultArgs> = $Result.GetResult<Prisma.$publicationsPayload, S>

  type publicationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<publicationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PublicationsCountAggregateInputType | true
    }

  export interface publicationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['publications'], meta: { name: 'publications' } }
    /**
     * Find zero or one Publications that matches the filter.
     * @param {publicationsFindUniqueArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends publicationsFindUniqueArgs>(args: SelectSubset<T, publicationsFindUniqueArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Publications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {publicationsFindUniqueOrThrowArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends publicationsFindUniqueOrThrowArgs>(args: SelectSubset<T, publicationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsFindFirstArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends publicationsFindFirstArgs>(args?: SelectSubset<T, publicationsFindFirstArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Publications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsFindFirstOrThrowArgs} args - Arguments to find a Publications
     * @example
     * // Get one Publications
     * const publications = await prisma.publications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends publicationsFindFirstOrThrowArgs>(args?: SelectSubset<T, publicationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Publications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Publications
     * const publications = await prisma.publications.findMany()
     * 
     * // Get first 10 Publications
     * const publications = await prisma.publications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const publicationsWithIdOnly = await prisma.publications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends publicationsFindManyArgs>(args?: SelectSubset<T, publicationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Publications.
     * @param {publicationsCreateArgs} args - Arguments to create a Publications.
     * @example
     * // Create one Publications
     * const Publications = await prisma.publications.create({
     *   data: {
     *     // ... data to create a Publications
     *   }
     * })
     * 
     */
    create<T extends publicationsCreateArgs>(args: SelectSubset<T, publicationsCreateArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Publications.
     * @param {publicationsCreateManyArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publications = await prisma.publications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends publicationsCreateManyArgs>(args?: SelectSubset<T, publicationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Publications and returns the data saved in the database.
     * @param {publicationsCreateManyAndReturnArgs} args - Arguments to create many Publications.
     * @example
     * // Create many Publications
     * const publications = await prisma.publications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Publications and only return the `id`
     * const publicationsWithIdOnly = await prisma.publications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends publicationsCreateManyAndReturnArgs>(args?: SelectSubset<T, publicationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Publications.
     * @param {publicationsDeleteArgs} args - Arguments to delete one Publications.
     * @example
     * // Delete one Publications
     * const Publications = await prisma.publications.delete({
     *   where: {
     *     // ... filter to delete one Publications
     *   }
     * })
     * 
     */
    delete<T extends publicationsDeleteArgs>(args: SelectSubset<T, publicationsDeleteArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Publications.
     * @param {publicationsUpdateArgs} args - Arguments to update one Publications.
     * @example
     * // Update one Publications
     * const publications = await prisma.publications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends publicationsUpdateArgs>(args: SelectSubset<T, publicationsUpdateArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Publications.
     * @param {publicationsDeleteManyArgs} args - Arguments to filter Publications to delete.
     * @example
     * // Delete a few Publications
     * const { count } = await prisma.publications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends publicationsDeleteManyArgs>(args?: SelectSubset<T, publicationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Publications
     * const publications = await prisma.publications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends publicationsUpdateManyArgs>(args: SelectSubset<T, publicationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Publications and returns the data updated in the database.
     * @param {publicationsUpdateManyAndReturnArgs} args - Arguments to update many Publications.
     * @example
     * // Update many Publications
     * const publications = await prisma.publications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Publications and only return the `id`
     * const publicationsWithIdOnly = await prisma.publications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends publicationsUpdateManyAndReturnArgs>(args: SelectSubset<T, publicationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Publications.
     * @param {publicationsUpsertArgs} args - Arguments to update or create a Publications.
     * @example
     * // Update or create a Publications
     * const publications = await prisma.publications.upsert({
     *   create: {
     *     // ... data to create a Publications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Publications we want to update
     *   }
     * })
     */
    upsert<T extends publicationsUpsertArgs>(args: SelectSubset<T, publicationsUpsertArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsCountArgs} args - Arguments to filter Publications to count.
     * @example
     * // Count the number of Publications
     * const count = await prisma.publications.count({
     *   where: {
     *     // ... the filter for the Publications we want to count
     *   }
     * })
    **/
    count<T extends publicationsCountArgs>(
      args?: Subset<T, publicationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PublicationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PublicationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PublicationsAggregateArgs>(args: Subset<T, PublicationsAggregateArgs>): Prisma.PrismaPromise<GetPublicationsAggregateType<T>>

    /**
     * Group by Publications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {publicationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends publicationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: publicationsGroupByArgs['orderBy'] }
        : { orderBy?: publicationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, publicationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPublicationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the publications model
   */
  readonly fields: publicationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for publications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__publicationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publication_authors<T extends publications$publication_authorsArgs<ExtArgs> = {}>(args?: Subset<T, publications$publication_authorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_authorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publication_entities<T extends publications$publication_entitiesArgs<ExtArgs> = {}>(args?: Subset<T, publications$publication_entitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_entitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publication_keywords<T extends publications$publication_keywordsArgs<ExtArgs> = {}>(args?: Subset<T, publications$publication_keywordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_keywordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    publication_mesh_terms<T extends publications$publication_mesh_termsArgs<ExtArgs> = {}>(args?: Subset<T, publications$publication_mesh_termsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$publication_mesh_termsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    text_sections<T extends publications$text_sectionsArgs<ExtArgs> = {}>(args?: Subset<T, publications$text_sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the publications model
   */
  interface publicationsFieldRefs {
    readonly id: FieldRef<"publications", 'String'>
    readonly pmcid: FieldRef<"publications", 'String'>
    readonly pmid: FieldRef<"publications", 'String'>
    readonly doi: FieldRef<"publications", 'String'>
    readonly title: FieldRef<"publications", 'String'>
    readonly abstract: FieldRef<"publications", 'String'>
    readonly publication_date: FieldRef<"publications", 'DateTime'>
    readonly journal: FieldRef<"publications", 'String'>
    readonly created_at: FieldRef<"publications", 'DateTime'>
    readonly updated_at: FieldRef<"publications", 'DateTime'>
    readonly abstract_generated: FieldRef<"publications", 'String'>
    readonly generation_type: FieldRef<"publications", 'String'>
    readonly key_findings: FieldRef<"publications", 'String'>
    readonly methodology: FieldRef<"publications", 'String'>
    readonly full_text_content: FieldRef<"publications", 'String'>
  }
    

  // Custom InputTypes
  /**
   * publications findUnique
   */
  export type publicationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications findUniqueOrThrow
   */
  export type publicationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications findFirst
   */
  export type publicationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publications.
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publications.
     */
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * publications findFirstOrThrow
   */
  export type publicationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for publications.
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of publications.
     */
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * publications findMany
   */
  export type publicationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * Filter, which publications to fetch.
     */
    where?: publicationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of publications to fetch.
     */
    orderBy?: publicationsOrderByWithRelationInput | publicationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing publications.
     */
    cursor?: publicationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` publications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` publications.
     */
    skip?: number
    distinct?: PublicationsScalarFieldEnum | PublicationsScalarFieldEnum[]
  }

  /**
   * publications create
   */
  export type publicationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * The data needed to create a publications.
     */
    data: XOR<publicationsCreateInput, publicationsUncheckedCreateInput>
  }

  /**
   * publications createMany
   */
  export type publicationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many publications.
     */
    data: publicationsCreateManyInput | publicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publications createManyAndReturn
   */
  export type publicationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * The data used to create many publications.
     */
    data: publicationsCreateManyInput | publicationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * publications update
   */
  export type publicationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * The data needed to update a publications.
     */
    data: XOR<publicationsUpdateInput, publicationsUncheckedUpdateInput>
    /**
     * Choose, which publications to update.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications updateMany
   */
  export type publicationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update publications.
     */
    data: XOR<publicationsUpdateManyMutationInput, publicationsUncheckedUpdateManyInput>
    /**
     * Filter which publications to update
     */
    where?: publicationsWhereInput
    /**
     * Limit how many publications to update.
     */
    limit?: number
  }

  /**
   * publications updateManyAndReturn
   */
  export type publicationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * The data used to update publications.
     */
    data: XOR<publicationsUpdateManyMutationInput, publicationsUncheckedUpdateManyInput>
    /**
     * Filter which publications to update
     */
    where?: publicationsWhereInput
    /**
     * Limit how many publications to update.
     */
    limit?: number
  }

  /**
   * publications upsert
   */
  export type publicationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * The filter to search for the publications to update in case it exists.
     */
    where: publicationsWhereUniqueInput
    /**
     * In case the publications found by the `where` argument doesn't exist, create a new publications with this data.
     */
    create: XOR<publicationsCreateInput, publicationsUncheckedCreateInput>
    /**
     * In case the publications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<publicationsUpdateInput, publicationsUncheckedUpdateInput>
  }

  /**
   * publications delete
   */
  export type publicationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
    /**
     * Filter which publications to delete.
     */
    where: publicationsWhereUniqueInput
  }

  /**
   * publications deleteMany
   */
  export type publicationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which publications to delete
     */
    where?: publicationsWhereInput
    /**
     * Limit how many publications to delete.
     */
    limit?: number
  }

  /**
   * publications.publication_authors
   */
  export type publications$publication_authorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_authors
     */
    select?: publication_authorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_authors
     */
    omit?: publication_authorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_authorsInclude<ExtArgs> | null
    where?: publication_authorsWhereInput
    orderBy?: publication_authorsOrderByWithRelationInput | publication_authorsOrderByWithRelationInput[]
    cursor?: publication_authorsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_authorsScalarFieldEnum | Publication_authorsScalarFieldEnum[]
  }

  /**
   * publications.publication_entities
   */
  export type publications$publication_entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_entities
     */
    select?: publication_entitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_entities
     */
    omit?: publication_entitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_entitiesInclude<ExtArgs> | null
    where?: publication_entitiesWhereInput
    orderBy?: publication_entitiesOrderByWithRelationInput | publication_entitiesOrderByWithRelationInput[]
    cursor?: publication_entitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_entitiesScalarFieldEnum | Publication_entitiesScalarFieldEnum[]
  }

  /**
   * publications.publication_keywords
   */
  export type publications$publication_keywordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_keywords
     */
    select?: publication_keywordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_keywords
     */
    omit?: publication_keywordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_keywordsInclude<ExtArgs> | null
    where?: publication_keywordsWhereInput
    orderBy?: publication_keywordsOrderByWithRelationInput | publication_keywordsOrderByWithRelationInput[]
    cursor?: publication_keywordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_keywordsScalarFieldEnum | Publication_keywordsScalarFieldEnum[]
  }

  /**
   * publications.publication_mesh_terms
   */
  export type publications$publication_mesh_termsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publication_mesh_terms
     */
    select?: publication_mesh_termsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publication_mesh_terms
     */
    omit?: publication_mesh_termsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publication_mesh_termsInclude<ExtArgs> | null
    where?: publication_mesh_termsWhereInput
    orderBy?: publication_mesh_termsOrderByWithRelationInput | publication_mesh_termsOrderByWithRelationInput[]
    cursor?: publication_mesh_termsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Publication_mesh_termsScalarFieldEnum | Publication_mesh_termsScalarFieldEnum[]
  }

  /**
   * publications.text_sections
   */
  export type publications$text_sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    where?: text_sectionsWhereInput
    orderBy?: text_sectionsOrderByWithRelationInput | text_sectionsOrderByWithRelationInput[]
    cursor?: text_sectionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Text_sectionsScalarFieldEnum | Text_sectionsScalarFieldEnum[]
  }

  /**
   * publications without action
   */
  export type publicationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the publications
     */
    select?: publicationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the publications
     */
    omit?: publicationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: publicationsInclude<ExtArgs> | null
  }


  /**
   * Model text_sections
   */

  export type AggregateText_sections = {
    _count: Text_sectionsCountAggregateOutputType | null
    _avg: Text_sectionsAvgAggregateOutputType | null
    _sum: Text_sectionsSumAggregateOutputType | null
    _min: Text_sectionsMinAggregateOutputType | null
    _max: Text_sectionsMaxAggregateOutputType | null
  }

  export type Text_sectionsAvgAggregateOutputType = {
    section_order: number | null
  }

  export type Text_sectionsSumAggregateOutputType = {
    section_order: number | null
  }

  export type Text_sectionsMinAggregateOutputType = {
    id: string | null
    publication_id: string | null
    section_name: string | null
    content: string | null
    section_order: number | null
  }

  export type Text_sectionsMaxAggregateOutputType = {
    id: string | null
    publication_id: string | null
    section_name: string | null
    content: string | null
    section_order: number | null
  }

  export type Text_sectionsCountAggregateOutputType = {
    id: number
    publication_id: number
    section_name: number
    content: number
    section_order: number
    _all: number
  }


  export type Text_sectionsAvgAggregateInputType = {
    section_order?: true
  }

  export type Text_sectionsSumAggregateInputType = {
    section_order?: true
  }

  export type Text_sectionsMinAggregateInputType = {
    id?: true
    publication_id?: true
    section_name?: true
    content?: true
    section_order?: true
  }

  export type Text_sectionsMaxAggregateInputType = {
    id?: true
    publication_id?: true
    section_name?: true
    content?: true
    section_order?: true
  }

  export type Text_sectionsCountAggregateInputType = {
    id?: true
    publication_id?: true
    section_name?: true
    content?: true
    section_order?: true
    _all?: true
  }

  export type Text_sectionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which text_sections to aggregate.
     */
    where?: text_sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of text_sections to fetch.
     */
    orderBy?: text_sectionsOrderByWithRelationInput | text_sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: text_sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` text_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` text_sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned text_sections
    **/
    _count?: true | Text_sectionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Text_sectionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Text_sectionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Text_sectionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Text_sectionsMaxAggregateInputType
  }

  export type GetText_sectionsAggregateType<T extends Text_sectionsAggregateArgs> = {
        [P in keyof T & keyof AggregateText_sections]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateText_sections[P]>
      : GetScalarType<T[P], AggregateText_sections[P]>
  }




  export type text_sectionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: text_sectionsWhereInput
    orderBy?: text_sectionsOrderByWithAggregationInput | text_sectionsOrderByWithAggregationInput[]
    by: Text_sectionsScalarFieldEnum[] | Text_sectionsScalarFieldEnum
    having?: text_sectionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Text_sectionsCountAggregateInputType | true
    _avg?: Text_sectionsAvgAggregateInputType
    _sum?: Text_sectionsSumAggregateInputType
    _min?: Text_sectionsMinAggregateInputType
    _max?: Text_sectionsMaxAggregateInputType
  }

  export type Text_sectionsGroupByOutputType = {
    id: string
    publication_id: string
    section_name: string
    content: string
    section_order: number | null
    _count: Text_sectionsCountAggregateOutputType | null
    _avg: Text_sectionsAvgAggregateOutputType | null
    _sum: Text_sectionsSumAggregateOutputType | null
    _min: Text_sectionsMinAggregateOutputType | null
    _max: Text_sectionsMaxAggregateOutputType | null
  }

  type GetText_sectionsGroupByPayload<T extends text_sectionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Text_sectionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Text_sectionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Text_sectionsGroupByOutputType[P]>
            : GetScalarType<T[P], Text_sectionsGroupByOutputType[P]>
        }
      >
    >


  export type text_sectionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publication_id?: boolean
    section_name?: boolean
    content?: boolean
    section_order?: boolean
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["text_sections"]>

  export type text_sectionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publication_id?: boolean
    section_name?: boolean
    content?: boolean
    section_order?: boolean
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["text_sections"]>

  export type text_sectionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    publication_id?: boolean
    section_name?: boolean
    content?: boolean
    section_order?: boolean
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["text_sections"]>

  export type text_sectionsSelectScalar = {
    id?: boolean
    publication_id?: boolean
    section_name?: boolean
    content?: boolean
    section_order?: boolean
  }

  export type text_sectionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "publication_id" | "section_name" | "content" | "section_order", ExtArgs["result"]["text_sections"]>
  export type text_sectionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type text_sectionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }
  export type text_sectionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    publications?: boolean | publicationsDefaultArgs<ExtArgs>
  }

  export type $text_sectionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "text_sections"
    objects: {
      publications: Prisma.$publicationsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      publication_id: string
      section_name: string
      content: string
      section_order: number | null
    }, ExtArgs["result"]["text_sections"]>
    composites: {}
  }

  type text_sectionsGetPayload<S extends boolean | null | undefined | text_sectionsDefaultArgs> = $Result.GetResult<Prisma.$text_sectionsPayload, S>

  type text_sectionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<text_sectionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Text_sectionsCountAggregateInputType | true
    }

  export interface text_sectionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['text_sections'], meta: { name: 'text_sections' } }
    /**
     * Find zero or one Text_sections that matches the filter.
     * @param {text_sectionsFindUniqueArgs} args - Arguments to find a Text_sections
     * @example
     * // Get one Text_sections
     * const text_sections = await prisma.text_sections.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends text_sectionsFindUniqueArgs>(args: SelectSubset<T, text_sectionsFindUniqueArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Text_sections that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {text_sectionsFindUniqueOrThrowArgs} args - Arguments to find a Text_sections
     * @example
     * // Get one Text_sections
     * const text_sections = await prisma.text_sections.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends text_sectionsFindUniqueOrThrowArgs>(args: SelectSubset<T, text_sectionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Text_sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {text_sectionsFindFirstArgs} args - Arguments to find a Text_sections
     * @example
     * // Get one Text_sections
     * const text_sections = await prisma.text_sections.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends text_sectionsFindFirstArgs>(args?: SelectSubset<T, text_sectionsFindFirstArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Text_sections that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {text_sectionsFindFirstOrThrowArgs} args - Arguments to find a Text_sections
     * @example
     * // Get one Text_sections
     * const text_sections = await prisma.text_sections.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends text_sectionsFindFirstOrThrowArgs>(args?: SelectSubset<T, text_sectionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Text_sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {text_sectionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Text_sections
     * const text_sections = await prisma.text_sections.findMany()
     * 
     * // Get first 10 Text_sections
     * const text_sections = await prisma.text_sections.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const text_sectionsWithIdOnly = await prisma.text_sections.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends text_sectionsFindManyArgs>(args?: SelectSubset<T, text_sectionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Text_sections.
     * @param {text_sectionsCreateArgs} args - Arguments to create a Text_sections.
     * @example
     * // Create one Text_sections
     * const Text_sections = await prisma.text_sections.create({
     *   data: {
     *     // ... data to create a Text_sections
     *   }
     * })
     * 
     */
    create<T extends text_sectionsCreateArgs>(args: SelectSubset<T, text_sectionsCreateArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Text_sections.
     * @param {text_sectionsCreateManyArgs} args - Arguments to create many Text_sections.
     * @example
     * // Create many Text_sections
     * const text_sections = await prisma.text_sections.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends text_sectionsCreateManyArgs>(args?: SelectSubset<T, text_sectionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Text_sections and returns the data saved in the database.
     * @param {text_sectionsCreateManyAndReturnArgs} args - Arguments to create many Text_sections.
     * @example
     * // Create many Text_sections
     * const text_sections = await prisma.text_sections.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Text_sections and only return the `id`
     * const text_sectionsWithIdOnly = await prisma.text_sections.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends text_sectionsCreateManyAndReturnArgs>(args?: SelectSubset<T, text_sectionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Text_sections.
     * @param {text_sectionsDeleteArgs} args - Arguments to delete one Text_sections.
     * @example
     * // Delete one Text_sections
     * const Text_sections = await prisma.text_sections.delete({
     *   where: {
     *     // ... filter to delete one Text_sections
     *   }
     * })
     * 
     */
    delete<T extends text_sectionsDeleteArgs>(args: SelectSubset<T, text_sectionsDeleteArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Text_sections.
     * @param {text_sectionsUpdateArgs} args - Arguments to update one Text_sections.
     * @example
     * // Update one Text_sections
     * const text_sections = await prisma.text_sections.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends text_sectionsUpdateArgs>(args: SelectSubset<T, text_sectionsUpdateArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Text_sections.
     * @param {text_sectionsDeleteManyArgs} args - Arguments to filter Text_sections to delete.
     * @example
     * // Delete a few Text_sections
     * const { count } = await prisma.text_sections.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends text_sectionsDeleteManyArgs>(args?: SelectSubset<T, text_sectionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Text_sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {text_sectionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Text_sections
     * const text_sections = await prisma.text_sections.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends text_sectionsUpdateManyArgs>(args: SelectSubset<T, text_sectionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Text_sections and returns the data updated in the database.
     * @param {text_sectionsUpdateManyAndReturnArgs} args - Arguments to update many Text_sections.
     * @example
     * // Update many Text_sections
     * const text_sections = await prisma.text_sections.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Text_sections and only return the `id`
     * const text_sectionsWithIdOnly = await prisma.text_sections.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends text_sectionsUpdateManyAndReturnArgs>(args: SelectSubset<T, text_sectionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Text_sections.
     * @param {text_sectionsUpsertArgs} args - Arguments to update or create a Text_sections.
     * @example
     * // Update or create a Text_sections
     * const text_sections = await prisma.text_sections.upsert({
     *   create: {
     *     // ... data to create a Text_sections
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Text_sections we want to update
     *   }
     * })
     */
    upsert<T extends text_sectionsUpsertArgs>(args: SelectSubset<T, text_sectionsUpsertArgs<ExtArgs>>): Prisma__text_sectionsClient<$Result.GetResult<Prisma.$text_sectionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Text_sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {text_sectionsCountArgs} args - Arguments to filter Text_sections to count.
     * @example
     * // Count the number of Text_sections
     * const count = await prisma.text_sections.count({
     *   where: {
     *     // ... the filter for the Text_sections we want to count
     *   }
     * })
    **/
    count<T extends text_sectionsCountArgs>(
      args?: Subset<T, text_sectionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Text_sectionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Text_sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Text_sectionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Text_sectionsAggregateArgs>(args: Subset<T, Text_sectionsAggregateArgs>): Prisma.PrismaPromise<GetText_sectionsAggregateType<T>>

    /**
     * Group by Text_sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {text_sectionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends text_sectionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: text_sectionsGroupByArgs['orderBy'] }
        : { orderBy?: text_sectionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, text_sectionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetText_sectionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the text_sections model
   */
  readonly fields: text_sectionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for text_sections.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__text_sectionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    publications<T extends publicationsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, publicationsDefaultArgs<ExtArgs>>): Prisma__publicationsClient<$Result.GetResult<Prisma.$publicationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the text_sections model
   */
  interface text_sectionsFieldRefs {
    readonly id: FieldRef<"text_sections", 'String'>
    readonly publication_id: FieldRef<"text_sections", 'String'>
    readonly section_name: FieldRef<"text_sections", 'String'>
    readonly content: FieldRef<"text_sections", 'String'>
    readonly section_order: FieldRef<"text_sections", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * text_sections findUnique
   */
  export type text_sectionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * Filter, which text_sections to fetch.
     */
    where: text_sectionsWhereUniqueInput
  }

  /**
   * text_sections findUniqueOrThrow
   */
  export type text_sectionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * Filter, which text_sections to fetch.
     */
    where: text_sectionsWhereUniqueInput
  }

  /**
   * text_sections findFirst
   */
  export type text_sectionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * Filter, which text_sections to fetch.
     */
    where?: text_sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of text_sections to fetch.
     */
    orderBy?: text_sectionsOrderByWithRelationInput | text_sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for text_sections.
     */
    cursor?: text_sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` text_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` text_sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of text_sections.
     */
    distinct?: Text_sectionsScalarFieldEnum | Text_sectionsScalarFieldEnum[]
  }

  /**
   * text_sections findFirstOrThrow
   */
  export type text_sectionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * Filter, which text_sections to fetch.
     */
    where?: text_sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of text_sections to fetch.
     */
    orderBy?: text_sectionsOrderByWithRelationInput | text_sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for text_sections.
     */
    cursor?: text_sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` text_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` text_sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of text_sections.
     */
    distinct?: Text_sectionsScalarFieldEnum | Text_sectionsScalarFieldEnum[]
  }

  /**
   * text_sections findMany
   */
  export type text_sectionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * Filter, which text_sections to fetch.
     */
    where?: text_sectionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of text_sections to fetch.
     */
    orderBy?: text_sectionsOrderByWithRelationInput | text_sectionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing text_sections.
     */
    cursor?: text_sectionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` text_sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` text_sections.
     */
    skip?: number
    distinct?: Text_sectionsScalarFieldEnum | Text_sectionsScalarFieldEnum[]
  }

  /**
   * text_sections create
   */
  export type text_sectionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * The data needed to create a text_sections.
     */
    data: XOR<text_sectionsCreateInput, text_sectionsUncheckedCreateInput>
  }

  /**
   * text_sections createMany
   */
  export type text_sectionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many text_sections.
     */
    data: text_sectionsCreateManyInput | text_sectionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * text_sections createManyAndReturn
   */
  export type text_sectionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * The data used to create many text_sections.
     */
    data: text_sectionsCreateManyInput | text_sectionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * text_sections update
   */
  export type text_sectionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * The data needed to update a text_sections.
     */
    data: XOR<text_sectionsUpdateInput, text_sectionsUncheckedUpdateInput>
    /**
     * Choose, which text_sections to update.
     */
    where: text_sectionsWhereUniqueInput
  }

  /**
   * text_sections updateMany
   */
  export type text_sectionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update text_sections.
     */
    data: XOR<text_sectionsUpdateManyMutationInput, text_sectionsUncheckedUpdateManyInput>
    /**
     * Filter which text_sections to update
     */
    where?: text_sectionsWhereInput
    /**
     * Limit how many text_sections to update.
     */
    limit?: number
  }

  /**
   * text_sections updateManyAndReturn
   */
  export type text_sectionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * The data used to update text_sections.
     */
    data: XOR<text_sectionsUpdateManyMutationInput, text_sectionsUncheckedUpdateManyInput>
    /**
     * Filter which text_sections to update
     */
    where?: text_sectionsWhereInput
    /**
     * Limit how many text_sections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * text_sections upsert
   */
  export type text_sectionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * The filter to search for the text_sections to update in case it exists.
     */
    where: text_sectionsWhereUniqueInput
    /**
     * In case the text_sections found by the `where` argument doesn't exist, create a new text_sections with this data.
     */
    create: XOR<text_sectionsCreateInput, text_sectionsUncheckedCreateInput>
    /**
     * In case the text_sections was found with the provided `where` argument, update it with this data.
     */
    update: XOR<text_sectionsUpdateInput, text_sectionsUncheckedUpdateInput>
  }

  /**
   * text_sections delete
   */
  export type text_sectionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
    /**
     * Filter which text_sections to delete.
     */
    where: text_sectionsWhereUniqueInput
  }

  /**
   * text_sections deleteMany
   */
  export type text_sectionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which text_sections to delete
     */
    where?: text_sectionsWhereInput
    /**
     * Limit how many text_sections to delete.
     */
    limit?: number
  }

  /**
   * text_sections without action
   */
  export type text_sectionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the text_sections
     */
    select?: text_sectionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the text_sections
     */
    omit?: text_sectionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: text_sectionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AuthorsScalarFieldEnum: {
    id: 'id',
    firstname: 'firstname',
    lastname: 'lastname',
    email: 'email',
    orcid: 'orcid',
    created_at: 'created_at'
  };

  export type AuthorsScalarFieldEnum = (typeof AuthorsScalarFieldEnum)[keyof typeof AuthorsScalarFieldEnum]


  export const EntitiesScalarFieldEnum: {
    id: 'id',
    entity_type: 'entity_type',
    entity_name: 'entity_name',
    normalized_name: 'normalized_name',
    description: 'description'
  };

  export type EntitiesScalarFieldEnum = (typeof EntitiesScalarFieldEnum)[keyof typeof EntitiesScalarFieldEnum]


  export const KeywordsScalarFieldEnum: {
    id: 'id',
    keyword: 'keyword',
    category: 'category'
  };

  export type KeywordsScalarFieldEnum = (typeof KeywordsScalarFieldEnum)[keyof typeof KeywordsScalarFieldEnum]


  export const Mesh_termsScalarFieldEnum: {
    id: 'id',
    term: 'term',
    tree_number: 'tree_number'
  };

  export type Mesh_termsScalarFieldEnum = (typeof Mesh_termsScalarFieldEnum)[keyof typeof Mesh_termsScalarFieldEnum]


  export const Publication_authorsScalarFieldEnum: {
    publication_id: 'publication_id',
    author_id: 'author_id',
    author_order: 'author_order',
    affiliation: 'affiliation'
  };

  export type Publication_authorsScalarFieldEnum = (typeof Publication_authorsScalarFieldEnum)[keyof typeof Publication_authorsScalarFieldEnum]


  export const Publication_entitiesScalarFieldEnum: {
    id: 'id',
    publication_id: 'publication_id',
    entity_id: 'entity_id',
    confidence: 'confidence',
    context: 'context'
  };

  export type Publication_entitiesScalarFieldEnum = (typeof Publication_entitiesScalarFieldEnum)[keyof typeof Publication_entitiesScalarFieldEnum]


  export const Publication_keywordsScalarFieldEnum: {
    publication_id: 'publication_id',
    keyword_id: 'keyword_id'
  };

  export type Publication_keywordsScalarFieldEnum = (typeof Publication_keywordsScalarFieldEnum)[keyof typeof Publication_keywordsScalarFieldEnum]


  export const Publication_mesh_termsScalarFieldEnum: {
    publication_id: 'publication_id',
    mesh_term_id: 'mesh_term_id',
    is_major_topic: 'is_major_topic'
  };

  export type Publication_mesh_termsScalarFieldEnum = (typeof Publication_mesh_termsScalarFieldEnum)[keyof typeof Publication_mesh_termsScalarFieldEnum]


  export const PublicationsScalarFieldEnum: {
    id: 'id',
    pmcid: 'pmcid',
    pmid: 'pmid',
    doi: 'doi',
    title: 'title',
    abstract: 'abstract',
    publication_date: 'publication_date',
    journal: 'journal',
    created_at: 'created_at',
    updated_at: 'updated_at',
    abstract_generated: 'abstract_generated',
    generation_type: 'generation_type',
    key_findings: 'key_findings',
    methodology: 'methodology',
    full_text_content: 'full_text_content'
  };

  export type PublicationsScalarFieldEnum = (typeof PublicationsScalarFieldEnum)[keyof typeof PublicationsScalarFieldEnum]


  export const Text_sectionsScalarFieldEnum: {
    id: 'id',
    publication_id: 'publication_id',
    section_name: 'section_name',
    content: 'content',
    section_order: 'section_order'
  };

  export type Text_sectionsScalarFieldEnum = (typeof Text_sectionsScalarFieldEnum)[keyof typeof Text_sectionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type authorsWhereInput = {
    AND?: authorsWhereInput | authorsWhereInput[]
    OR?: authorsWhereInput[]
    NOT?: authorsWhereInput | authorsWhereInput[]
    id?: UuidFilter<"authors"> | string
    firstname?: StringNullableFilter<"authors"> | string | null
    lastname?: StringFilter<"authors"> | string
    email?: StringNullableFilter<"authors"> | string | null
    orcid?: StringNullableFilter<"authors"> | string | null
    created_at?: DateTimeFilter<"authors"> | Date | string
    publication_authors?: Publication_authorsListRelationFilter
  }

  export type authorsOrderByWithRelationInput = {
    id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrder
    email?: SortOrderInput | SortOrder
    orcid?: SortOrderInput | SortOrder
    created_at?: SortOrder
    publication_authors?: publication_authorsOrderByRelationAggregateInput
  }

  export type authorsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: authorsWhereInput | authorsWhereInput[]
    OR?: authorsWhereInput[]
    NOT?: authorsWhereInput | authorsWhereInput[]
    firstname?: StringNullableFilter<"authors"> | string | null
    lastname?: StringFilter<"authors"> | string
    email?: StringNullableFilter<"authors"> | string | null
    orcid?: StringNullableFilter<"authors"> | string | null
    created_at?: DateTimeFilter<"authors"> | Date | string
    publication_authors?: Publication_authorsListRelationFilter
  }, "id">

  export type authorsOrderByWithAggregationInput = {
    id?: SortOrder
    firstname?: SortOrderInput | SortOrder
    lastname?: SortOrder
    email?: SortOrderInput | SortOrder
    orcid?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: authorsCountOrderByAggregateInput
    _max?: authorsMaxOrderByAggregateInput
    _min?: authorsMinOrderByAggregateInput
  }

  export type authorsScalarWhereWithAggregatesInput = {
    AND?: authorsScalarWhereWithAggregatesInput | authorsScalarWhereWithAggregatesInput[]
    OR?: authorsScalarWhereWithAggregatesInput[]
    NOT?: authorsScalarWhereWithAggregatesInput | authorsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"authors"> | string
    firstname?: StringNullableWithAggregatesFilter<"authors"> | string | null
    lastname?: StringWithAggregatesFilter<"authors"> | string
    email?: StringNullableWithAggregatesFilter<"authors"> | string | null
    orcid?: StringNullableWithAggregatesFilter<"authors"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"authors"> | Date | string
  }

  export type entitiesWhereInput = {
    AND?: entitiesWhereInput | entitiesWhereInput[]
    OR?: entitiesWhereInput[]
    NOT?: entitiesWhereInput | entitiesWhereInput[]
    id?: UuidFilter<"entities"> | string
    entity_type?: StringFilter<"entities"> | string
    entity_name?: StringFilter<"entities"> | string
    normalized_name?: StringNullableFilter<"entities"> | string | null
    description?: StringNullableFilter<"entities"> | string | null
    publication_entities?: Publication_entitiesListRelationFilter
  }

  export type entitiesOrderByWithRelationInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_name?: SortOrder
    normalized_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    publication_entities?: publication_entitiesOrderByRelationAggregateInput
  }

  export type entitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: entitiesWhereInput | entitiesWhereInput[]
    OR?: entitiesWhereInput[]
    NOT?: entitiesWhereInput | entitiesWhereInput[]
    entity_type?: StringFilter<"entities"> | string
    entity_name?: StringFilter<"entities"> | string
    normalized_name?: StringNullableFilter<"entities"> | string | null
    description?: StringNullableFilter<"entities"> | string | null
    publication_entities?: Publication_entitiesListRelationFilter
  }, "id">

  export type entitiesOrderByWithAggregationInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_name?: SortOrder
    normalized_name?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: entitiesCountOrderByAggregateInput
    _max?: entitiesMaxOrderByAggregateInput
    _min?: entitiesMinOrderByAggregateInput
  }

  export type entitiesScalarWhereWithAggregatesInput = {
    AND?: entitiesScalarWhereWithAggregatesInput | entitiesScalarWhereWithAggregatesInput[]
    OR?: entitiesScalarWhereWithAggregatesInput[]
    NOT?: entitiesScalarWhereWithAggregatesInput | entitiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"entities"> | string
    entity_type?: StringWithAggregatesFilter<"entities"> | string
    entity_name?: StringWithAggregatesFilter<"entities"> | string
    normalized_name?: StringNullableWithAggregatesFilter<"entities"> | string | null
    description?: StringNullableWithAggregatesFilter<"entities"> | string | null
  }

  export type keywordsWhereInput = {
    AND?: keywordsWhereInput | keywordsWhereInput[]
    OR?: keywordsWhereInput[]
    NOT?: keywordsWhereInput | keywordsWhereInput[]
    id?: UuidFilter<"keywords"> | string
    keyword?: StringFilter<"keywords"> | string
    category?: StringNullableFilter<"keywords"> | string | null
    publication_keywords?: Publication_keywordsListRelationFilter
  }

  export type keywordsOrderByWithRelationInput = {
    id?: SortOrder
    keyword?: SortOrder
    category?: SortOrderInput | SortOrder
    publication_keywords?: publication_keywordsOrderByRelationAggregateInput
  }

  export type keywordsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyword?: string
    AND?: keywordsWhereInput | keywordsWhereInput[]
    OR?: keywordsWhereInput[]
    NOT?: keywordsWhereInput | keywordsWhereInput[]
    category?: StringNullableFilter<"keywords"> | string | null
    publication_keywords?: Publication_keywordsListRelationFilter
  }, "id" | "keyword">

  export type keywordsOrderByWithAggregationInput = {
    id?: SortOrder
    keyword?: SortOrder
    category?: SortOrderInput | SortOrder
    _count?: keywordsCountOrderByAggregateInput
    _max?: keywordsMaxOrderByAggregateInput
    _min?: keywordsMinOrderByAggregateInput
  }

  export type keywordsScalarWhereWithAggregatesInput = {
    AND?: keywordsScalarWhereWithAggregatesInput | keywordsScalarWhereWithAggregatesInput[]
    OR?: keywordsScalarWhereWithAggregatesInput[]
    NOT?: keywordsScalarWhereWithAggregatesInput | keywordsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"keywords"> | string
    keyword?: StringWithAggregatesFilter<"keywords"> | string
    category?: StringNullableWithAggregatesFilter<"keywords"> | string | null
  }

  export type mesh_termsWhereInput = {
    AND?: mesh_termsWhereInput | mesh_termsWhereInput[]
    OR?: mesh_termsWhereInput[]
    NOT?: mesh_termsWhereInput | mesh_termsWhereInput[]
    id?: UuidFilter<"mesh_terms"> | string
    term?: StringFilter<"mesh_terms"> | string
    tree_number?: StringNullableFilter<"mesh_terms"> | string | null
    publication_mesh_terms?: Publication_mesh_termsListRelationFilter
  }

  export type mesh_termsOrderByWithRelationInput = {
    id?: SortOrder
    term?: SortOrder
    tree_number?: SortOrderInput | SortOrder
    publication_mesh_terms?: publication_mesh_termsOrderByRelationAggregateInput
  }

  export type mesh_termsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    term?: string
    AND?: mesh_termsWhereInput | mesh_termsWhereInput[]
    OR?: mesh_termsWhereInput[]
    NOT?: mesh_termsWhereInput | mesh_termsWhereInput[]
    tree_number?: StringNullableFilter<"mesh_terms"> | string | null
    publication_mesh_terms?: Publication_mesh_termsListRelationFilter
  }, "id" | "term">

  export type mesh_termsOrderByWithAggregationInput = {
    id?: SortOrder
    term?: SortOrder
    tree_number?: SortOrderInput | SortOrder
    _count?: mesh_termsCountOrderByAggregateInput
    _max?: mesh_termsMaxOrderByAggregateInput
    _min?: mesh_termsMinOrderByAggregateInput
  }

  export type mesh_termsScalarWhereWithAggregatesInput = {
    AND?: mesh_termsScalarWhereWithAggregatesInput | mesh_termsScalarWhereWithAggregatesInput[]
    OR?: mesh_termsScalarWhereWithAggregatesInput[]
    NOT?: mesh_termsScalarWhereWithAggregatesInput | mesh_termsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"mesh_terms"> | string
    term?: StringWithAggregatesFilter<"mesh_terms"> | string
    tree_number?: StringNullableWithAggregatesFilter<"mesh_terms"> | string | null
  }

  export type publication_authorsWhereInput = {
    AND?: publication_authorsWhereInput | publication_authorsWhereInput[]
    OR?: publication_authorsWhereInput[]
    NOT?: publication_authorsWhereInput | publication_authorsWhereInput[]
    publication_id?: UuidFilter<"publication_authors"> | string
    author_id?: UuidFilter<"publication_authors"> | string
    author_order?: IntFilter<"publication_authors"> | number
    affiliation?: StringNullableFilter<"publication_authors"> | string | null
    authors?: XOR<AuthorsScalarRelationFilter, authorsWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }

  export type publication_authorsOrderByWithRelationInput = {
    publication_id?: SortOrder
    author_id?: SortOrder
    author_order?: SortOrder
    affiliation?: SortOrderInput | SortOrder
    authors?: authorsOrderByWithRelationInput
    publications?: publicationsOrderByWithRelationInput
  }

  export type publication_authorsWhereUniqueInput = Prisma.AtLeast<{
    publication_id_author_id?: publication_authorsPublication_idAuthor_idCompoundUniqueInput
    AND?: publication_authorsWhereInput | publication_authorsWhereInput[]
    OR?: publication_authorsWhereInput[]
    NOT?: publication_authorsWhereInput | publication_authorsWhereInput[]
    publication_id?: UuidFilter<"publication_authors"> | string
    author_id?: UuidFilter<"publication_authors"> | string
    author_order?: IntFilter<"publication_authors"> | number
    affiliation?: StringNullableFilter<"publication_authors"> | string | null
    authors?: XOR<AuthorsScalarRelationFilter, authorsWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }, "publication_id_author_id">

  export type publication_authorsOrderByWithAggregationInput = {
    publication_id?: SortOrder
    author_id?: SortOrder
    author_order?: SortOrder
    affiliation?: SortOrderInput | SortOrder
    _count?: publication_authorsCountOrderByAggregateInput
    _avg?: publication_authorsAvgOrderByAggregateInput
    _max?: publication_authorsMaxOrderByAggregateInput
    _min?: publication_authorsMinOrderByAggregateInput
    _sum?: publication_authorsSumOrderByAggregateInput
  }

  export type publication_authorsScalarWhereWithAggregatesInput = {
    AND?: publication_authorsScalarWhereWithAggregatesInput | publication_authorsScalarWhereWithAggregatesInput[]
    OR?: publication_authorsScalarWhereWithAggregatesInput[]
    NOT?: publication_authorsScalarWhereWithAggregatesInput | publication_authorsScalarWhereWithAggregatesInput[]
    publication_id?: UuidWithAggregatesFilter<"publication_authors"> | string
    author_id?: UuidWithAggregatesFilter<"publication_authors"> | string
    author_order?: IntWithAggregatesFilter<"publication_authors"> | number
    affiliation?: StringNullableWithAggregatesFilter<"publication_authors"> | string | null
  }

  export type publication_entitiesWhereInput = {
    AND?: publication_entitiesWhereInput | publication_entitiesWhereInput[]
    OR?: publication_entitiesWhereInput[]
    NOT?: publication_entitiesWhereInput | publication_entitiesWhereInput[]
    id?: UuidFilter<"publication_entities"> | string
    publication_id?: UuidFilter<"publication_entities"> | string
    entity_id?: UuidFilter<"publication_entities"> | string
    confidence?: FloatNullableFilter<"publication_entities"> | number | null
    context?: StringNullableFilter<"publication_entities"> | string | null
    entities?: XOR<EntitiesScalarRelationFilter, entitiesWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }

  export type publication_entitiesOrderByWithRelationInput = {
    id?: SortOrder
    publication_id?: SortOrder
    entity_id?: SortOrder
    confidence?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    entities?: entitiesOrderByWithRelationInput
    publications?: publicationsOrderByWithRelationInput
  }

  export type publication_entitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: publication_entitiesWhereInput | publication_entitiesWhereInput[]
    OR?: publication_entitiesWhereInput[]
    NOT?: publication_entitiesWhereInput | publication_entitiesWhereInput[]
    publication_id?: UuidFilter<"publication_entities"> | string
    entity_id?: UuidFilter<"publication_entities"> | string
    confidence?: FloatNullableFilter<"publication_entities"> | number | null
    context?: StringNullableFilter<"publication_entities"> | string | null
    entities?: XOR<EntitiesScalarRelationFilter, entitiesWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }, "id">

  export type publication_entitiesOrderByWithAggregationInput = {
    id?: SortOrder
    publication_id?: SortOrder
    entity_id?: SortOrder
    confidence?: SortOrderInput | SortOrder
    context?: SortOrderInput | SortOrder
    _count?: publication_entitiesCountOrderByAggregateInput
    _avg?: publication_entitiesAvgOrderByAggregateInput
    _max?: publication_entitiesMaxOrderByAggregateInput
    _min?: publication_entitiesMinOrderByAggregateInput
    _sum?: publication_entitiesSumOrderByAggregateInput
  }

  export type publication_entitiesScalarWhereWithAggregatesInput = {
    AND?: publication_entitiesScalarWhereWithAggregatesInput | publication_entitiesScalarWhereWithAggregatesInput[]
    OR?: publication_entitiesScalarWhereWithAggregatesInput[]
    NOT?: publication_entitiesScalarWhereWithAggregatesInput | publication_entitiesScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"publication_entities"> | string
    publication_id?: UuidWithAggregatesFilter<"publication_entities"> | string
    entity_id?: UuidWithAggregatesFilter<"publication_entities"> | string
    confidence?: FloatNullableWithAggregatesFilter<"publication_entities"> | number | null
    context?: StringNullableWithAggregatesFilter<"publication_entities"> | string | null
  }

  export type publication_keywordsWhereInput = {
    AND?: publication_keywordsWhereInput | publication_keywordsWhereInput[]
    OR?: publication_keywordsWhereInput[]
    NOT?: publication_keywordsWhereInput | publication_keywordsWhereInput[]
    publication_id?: UuidFilter<"publication_keywords"> | string
    keyword_id?: UuidFilter<"publication_keywords"> | string
    keywords?: XOR<KeywordsScalarRelationFilter, keywordsWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }

  export type publication_keywordsOrderByWithRelationInput = {
    publication_id?: SortOrder
    keyword_id?: SortOrder
    keywords?: keywordsOrderByWithRelationInput
    publications?: publicationsOrderByWithRelationInput
  }

  export type publication_keywordsWhereUniqueInput = Prisma.AtLeast<{
    publication_id_keyword_id?: publication_keywordsPublication_idKeyword_idCompoundUniqueInput
    AND?: publication_keywordsWhereInput | publication_keywordsWhereInput[]
    OR?: publication_keywordsWhereInput[]
    NOT?: publication_keywordsWhereInput | publication_keywordsWhereInput[]
    publication_id?: UuidFilter<"publication_keywords"> | string
    keyword_id?: UuidFilter<"publication_keywords"> | string
    keywords?: XOR<KeywordsScalarRelationFilter, keywordsWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }, "publication_id_keyword_id">

  export type publication_keywordsOrderByWithAggregationInput = {
    publication_id?: SortOrder
    keyword_id?: SortOrder
    _count?: publication_keywordsCountOrderByAggregateInput
    _max?: publication_keywordsMaxOrderByAggregateInput
    _min?: publication_keywordsMinOrderByAggregateInput
  }

  export type publication_keywordsScalarWhereWithAggregatesInput = {
    AND?: publication_keywordsScalarWhereWithAggregatesInput | publication_keywordsScalarWhereWithAggregatesInput[]
    OR?: publication_keywordsScalarWhereWithAggregatesInput[]
    NOT?: publication_keywordsScalarWhereWithAggregatesInput | publication_keywordsScalarWhereWithAggregatesInput[]
    publication_id?: UuidWithAggregatesFilter<"publication_keywords"> | string
    keyword_id?: UuidWithAggregatesFilter<"publication_keywords"> | string
  }

  export type publication_mesh_termsWhereInput = {
    AND?: publication_mesh_termsWhereInput | publication_mesh_termsWhereInput[]
    OR?: publication_mesh_termsWhereInput[]
    NOT?: publication_mesh_termsWhereInput | publication_mesh_termsWhereInput[]
    publication_id?: UuidFilter<"publication_mesh_terms"> | string
    mesh_term_id?: UuidFilter<"publication_mesh_terms"> | string
    is_major_topic?: BoolFilter<"publication_mesh_terms"> | boolean
    mesh_terms?: XOR<Mesh_termsScalarRelationFilter, mesh_termsWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }

  export type publication_mesh_termsOrderByWithRelationInput = {
    publication_id?: SortOrder
    mesh_term_id?: SortOrder
    is_major_topic?: SortOrder
    mesh_terms?: mesh_termsOrderByWithRelationInput
    publications?: publicationsOrderByWithRelationInput
  }

  export type publication_mesh_termsWhereUniqueInput = Prisma.AtLeast<{
    publication_id_mesh_term_id?: publication_mesh_termsPublication_idMesh_term_idCompoundUniqueInput
    AND?: publication_mesh_termsWhereInput | publication_mesh_termsWhereInput[]
    OR?: publication_mesh_termsWhereInput[]
    NOT?: publication_mesh_termsWhereInput | publication_mesh_termsWhereInput[]
    publication_id?: UuidFilter<"publication_mesh_terms"> | string
    mesh_term_id?: UuidFilter<"publication_mesh_terms"> | string
    is_major_topic?: BoolFilter<"publication_mesh_terms"> | boolean
    mesh_terms?: XOR<Mesh_termsScalarRelationFilter, mesh_termsWhereInput>
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }, "publication_id_mesh_term_id">

  export type publication_mesh_termsOrderByWithAggregationInput = {
    publication_id?: SortOrder
    mesh_term_id?: SortOrder
    is_major_topic?: SortOrder
    _count?: publication_mesh_termsCountOrderByAggregateInput
    _max?: publication_mesh_termsMaxOrderByAggregateInput
    _min?: publication_mesh_termsMinOrderByAggregateInput
  }

  export type publication_mesh_termsScalarWhereWithAggregatesInput = {
    AND?: publication_mesh_termsScalarWhereWithAggregatesInput | publication_mesh_termsScalarWhereWithAggregatesInput[]
    OR?: publication_mesh_termsScalarWhereWithAggregatesInput[]
    NOT?: publication_mesh_termsScalarWhereWithAggregatesInput | publication_mesh_termsScalarWhereWithAggregatesInput[]
    publication_id?: UuidWithAggregatesFilter<"publication_mesh_terms"> | string
    mesh_term_id?: UuidWithAggregatesFilter<"publication_mesh_terms"> | string
    is_major_topic?: BoolWithAggregatesFilter<"publication_mesh_terms"> | boolean
  }

  export type publicationsWhereInput = {
    AND?: publicationsWhereInput | publicationsWhereInput[]
    OR?: publicationsWhereInput[]
    NOT?: publicationsWhereInput | publicationsWhereInput[]
    id?: UuidFilter<"publications"> | string
    pmcid?: StringFilter<"publications"> | string
    pmid?: StringNullableFilter<"publications"> | string | null
    doi?: StringNullableFilter<"publications"> | string | null
    title?: StringFilter<"publications"> | string
    abstract?: StringNullableFilter<"publications"> | string | null
    publication_date?: DateTimeNullableFilter<"publications"> | Date | string | null
    journal?: StringNullableFilter<"publications"> | string | null
    created_at?: DateTimeFilter<"publications"> | Date | string
    updated_at?: DateTimeFilter<"publications"> | Date | string
    abstract_generated?: StringNullableFilter<"publications"> | string | null
    generation_type?: StringNullableFilter<"publications"> | string | null
    key_findings?: StringNullableFilter<"publications"> | string | null
    methodology?: StringNullableFilter<"publications"> | string | null
    full_text_content?: StringNullableFilter<"publications"> | string | null
    publication_authors?: Publication_authorsListRelationFilter
    publication_entities?: Publication_entitiesListRelationFilter
    publication_keywords?: Publication_keywordsListRelationFilter
    publication_mesh_terms?: Publication_mesh_termsListRelationFilter
    text_sections?: Text_sectionsListRelationFilter
  }

  export type publicationsOrderByWithRelationInput = {
    id?: SortOrder
    pmcid?: SortOrder
    pmid?: SortOrderInput | SortOrder
    doi?: SortOrderInput | SortOrder
    title?: SortOrder
    abstract?: SortOrderInput | SortOrder
    publication_date?: SortOrderInput | SortOrder
    journal?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    abstract_generated?: SortOrderInput | SortOrder
    generation_type?: SortOrderInput | SortOrder
    key_findings?: SortOrderInput | SortOrder
    methodology?: SortOrderInput | SortOrder
    full_text_content?: SortOrderInput | SortOrder
    publication_authors?: publication_authorsOrderByRelationAggregateInput
    publication_entities?: publication_entitiesOrderByRelationAggregateInput
    publication_keywords?: publication_keywordsOrderByRelationAggregateInput
    publication_mesh_terms?: publication_mesh_termsOrderByRelationAggregateInput
    text_sections?: text_sectionsOrderByRelationAggregateInput
  }

  export type publicationsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pmcid?: string
    AND?: publicationsWhereInput | publicationsWhereInput[]
    OR?: publicationsWhereInput[]
    NOT?: publicationsWhereInput | publicationsWhereInput[]
    pmid?: StringNullableFilter<"publications"> | string | null
    doi?: StringNullableFilter<"publications"> | string | null
    title?: StringFilter<"publications"> | string
    abstract?: StringNullableFilter<"publications"> | string | null
    publication_date?: DateTimeNullableFilter<"publications"> | Date | string | null
    journal?: StringNullableFilter<"publications"> | string | null
    created_at?: DateTimeFilter<"publications"> | Date | string
    updated_at?: DateTimeFilter<"publications"> | Date | string
    abstract_generated?: StringNullableFilter<"publications"> | string | null
    generation_type?: StringNullableFilter<"publications"> | string | null
    key_findings?: StringNullableFilter<"publications"> | string | null
    methodology?: StringNullableFilter<"publications"> | string | null
    full_text_content?: StringNullableFilter<"publications"> | string | null
    publication_authors?: Publication_authorsListRelationFilter
    publication_entities?: Publication_entitiesListRelationFilter
    publication_keywords?: Publication_keywordsListRelationFilter
    publication_mesh_terms?: Publication_mesh_termsListRelationFilter
    text_sections?: Text_sectionsListRelationFilter
  }, "id" | "pmcid">

  export type publicationsOrderByWithAggregationInput = {
    id?: SortOrder
    pmcid?: SortOrder
    pmid?: SortOrderInput | SortOrder
    doi?: SortOrderInput | SortOrder
    title?: SortOrder
    abstract?: SortOrderInput | SortOrder
    publication_date?: SortOrderInput | SortOrder
    journal?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    abstract_generated?: SortOrderInput | SortOrder
    generation_type?: SortOrderInput | SortOrder
    key_findings?: SortOrderInput | SortOrder
    methodology?: SortOrderInput | SortOrder
    full_text_content?: SortOrderInput | SortOrder
    _count?: publicationsCountOrderByAggregateInput
    _max?: publicationsMaxOrderByAggregateInput
    _min?: publicationsMinOrderByAggregateInput
  }

  export type publicationsScalarWhereWithAggregatesInput = {
    AND?: publicationsScalarWhereWithAggregatesInput | publicationsScalarWhereWithAggregatesInput[]
    OR?: publicationsScalarWhereWithAggregatesInput[]
    NOT?: publicationsScalarWhereWithAggregatesInput | publicationsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"publications"> | string
    pmcid?: StringWithAggregatesFilter<"publications"> | string
    pmid?: StringNullableWithAggregatesFilter<"publications"> | string | null
    doi?: StringNullableWithAggregatesFilter<"publications"> | string | null
    title?: StringWithAggregatesFilter<"publications"> | string
    abstract?: StringNullableWithAggregatesFilter<"publications"> | string | null
    publication_date?: DateTimeNullableWithAggregatesFilter<"publications"> | Date | string | null
    journal?: StringNullableWithAggregatesFilter<"publications"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"publications"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"publications"> | Date | string
    abstract_generated?: StringNullableWithAggregatesFilter<"publications"> | string | null
    generation_type?: StringNullableWithAggregatesFilter<"publications"> | string | null
    key_findings?: StringNullableWithAggregatesFilter<"publications"> | string | null
    methodology?: StringNullableWithAggregatesFilter<"publications"> | string | null
    full_text_content?: StringNullableWithAggregatesFilter<"publications"> | string | null
  }

  export type text_sectionsWhereInput = {
    AND?: text_sectionsWhereInput | text_sectionsWhereInput[]
    OR?: text_sectionsWhereInput[]
    NOT?: text_sectionsWhereInput | text_sectionsWhereInput[]
    id?: UuidFilter<"text_sections"> | string
    publication_id?: UuidFilter<"text_sections"> | string
    section_name?: StringFilter<"text_sections"> | string
    content?: StringFilter<"text_sections"> | string
    section_order?: IntNullableFilter<"text_sections"> | number | null
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }

  export type text_sectionsOrderByWithRelationInput = {
    id?: SortOrder
    publication_id?: SortOrder
    section_name?: SortOrder
    content?: SortOrder
    section_order?: SortOrderInput | SortOrder
    publications?: publicationsOrderByWithRelationInput
  }

  export type text_sectionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: text_sectionsWhereInput | text_sectionsWhereInput[]
    OR?: text_sectionsWhereInput[]
    NOT?: text_sectionsWhereInput | text_sectionsWhereInput[]
    publication_id?: UuidFilter<"text_sections"> | string
    section_name?: StringFilter<"text_sections"> | string
    content?: StringFilter<"text_sections"> | string
    section_order?: IntNullableFilter<"text_sections"> | number | null
    publications?: XOR<PublicationsScalarRelationFilter, publicationsWhereInput>
  }, "id">

  export type text_sectionsOrderByWithAggregationInput = {
    id?: SortOrder
    publication_id?: SortOrder
    section_name?: SortOrder
    content?: SortOrder
    section_order?: SortOrderInput | SortOrder
    _count?: text_sectionsCountOrderByAggregateInput
    _avg?: text_sectionsAvgOrderByAggregateInput
    _max?: text_sectionsMaxOrderByAggregateInput
    _min?: text_sectionsMinOrderByAggregateInput
    _sum?: text_sectionsSumOrderByAggregateInput
  }

  export type text_sectionsScalarWhereWithAggregatesInput = {
    AND?: text_sectionsScalarWhereWithAggregatesInput | text_sectionsScalarWhereWithAggregatesInput[]
    OR?: text_sectionsScalarWhereWithAggregatesInput[]
    NOT?: text_sectionsScalarWhereWithAggregatesInput | text_sectionsScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"text_sections"> | string
    publication_id?: UuidWithAggregatesFilter<"text_sections"> | string
    section_name?: StringWithAggregatesFilter<"text_sections"> | string
    content?: StringWithAggregatesFilter<"text_sections"> | string
    section_order?: IntNullableWithAggregatesFilter<"text_sections"> | number | null
  }

  export type authorsCreateInput = {
    id?: string
    firstname?: string | null
    lastname: string
    email?: string | null
    orcid?: string | null
    created_at: Date | string
    publication_authors?: publication_authorsCreateNestedManyWithoutAuthorsInput
  }

  export type authorsUncheckedCreateInput = {
    id?: string
    firstname?: string | null
    lastname: string
    email?: string | null
    orcid?: string | null
    created_at: Date | string
    publication_authors?: publication_authorsUncheckedCreateNestedManyWithoutAuthorsInput
  }

  export type authorsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orcid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    publication_authors?: publication_authorsUpdateManyWithoutAuthorsNestedInput
  }

  export type authorsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orcid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    publication_authors?: publication_authorsUncheckedUpdateManyWithoutAuthorsNestedInput
  }

  export type authorsCreateManyInput = {
    id?: string
    firstname?: string | null
    lastname: string
    email?: string | null
    orcid?: string | null
    created_at: Date | string
  }

  export type authorsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orcid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authorsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orcid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type entitiesCreateInput = {
    id?: string
    entity_type: string
    entity_name: string
    normalized_name?: string | null
    description?: string | null
    publication_entities?: publication_entitiesCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUncheckedCreateInput = {
    id?: string
    entity_type: string
    entity_name: string
    normalized_name?: string | null
    description?: string | null
    publication_entities?: publication_entitiesUncheckedCreateNestedManyWithoutEntitiesInput
  }

  export type entitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_name?: StringFieldUpdateOperationsInput | string
    normalized_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_entities?: publication_entitiesUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_name?: StringFieldUpdateOperationsInput | string
    normalized_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    publication_entities?: publication_entitiesUncheckedUpdateManyWithoutEntitiesNestedInput
  }

  export type entitiesCreateManyInput = {
    id?: string
    entity_type: string
    entity_name: string
    normalized_name?: string | null
    description?: string | null
  }

  export type entitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_name?: StringFieldUpdateOperationsInput | string
    normalized_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type entitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_name?: StringFieldUpdateOperationsInput | string
    normalized_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keywordsCreateInput = {
    id?: string
    keyword: string
    category?: string | null
    publication_keywords?: publication_keywordsCreateNestedManyWithoutKeywordsInput
  }

  export type keywordsUncheckedCreateInput = {
    id?: string
    keyword: string
    category?: string | null
    publication_keywords?: publication_keywordsUncheckedCreateNestedManyWithoutKeywordsInput
  }

  export type keywordsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_keywords?: publication_keywordsUpdateManyWithoutKeywordsNestedInput
  }

  export type keywordsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    publication_keywords?: publication_keywordsUncheckedUpdateManyWithoutKeywordsNestedInput
  }

  export type keywordsCreateManyInput = {
    id?: string
    keyword: string
    category?: string | null
  }

  export type keywordsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keywordsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mesh_termsCreateInput = {
    id?: string
    term: string
    tree_number?: string | null
    publication_mesh_terms?: publication_mesh_termsCreateNestedManyWithoutMesh_termsInput
  }

  export type mesh_termsUncheckedCreateInput = {
    id?: string
    term: string
    tree_number?: string | null
    publication_mesh_terms?: publication_mesh_termsUncheckedCreateNestedManyWithoutMesh_termsInput
  }

  export type mesh_termsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    tree_number?: NullableStringFieldUpdateOperationsInput | string | null
    publication_mesh_terms?: publication_mesh_termsUpdateManyWithoutMesh_termsNestedInput
  }

  export type mesh_termsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    tree_number?: NullableStringFieldUpdateOperationsInput | string | null
    publication_mesh_terms?: publication_mesh_termsUncheckedUpdateManyWithoutMesh_termsNestedInput
  }

  export type mesh_termsCreateManyInput = {
    id?: string
    term: string
    tree_number?: string | null
  }

  export type mesh_termsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    tree_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mesh_termsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    tree_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_authorsCreateInput = {
    author_order: number
    affiliation?: string | null
    authors: authorsCreateNestedOneWithoutPublication_authorsInput
    publications: publicationsCreateNestedOneWithoutPublication_authorsInput
  }

  export type publication_authorsUncheckedCreateInput = {
    publication_id: string
    author_id: string
    author_order: number
    affiliation?: string | null
  }

  export type publication_authorsUpdateInput = {
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: authorsUpdateOneRequiredWithoutPublication_authorsNestedInput
    publications?: publicationsUpdateOneRequiredWithoutPublication_authorsNestedInput
  }

  export type publication_authorsUncheckedUpdateInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_authorsCreateManyInput = {
    publication_id: string
    author_id: string
    author_order: number
    affiliation?: string | null
  }

  export type publication_authorsUpdateManyMutationInput = {
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_authorsUncheckedUpdateManyInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    author_id?: StringFieldUpdateOperationsInput | string
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesCreateInput = {
    id?: string
    confidence?: number | null
    context?: string | null
    entities: entitiesCreateNestedOneWithoutPublication_entitiesInput
    publications: publicationsCreateNestedOneWithoutPublication_entitiesInput
  }

  export type publication_entitiesUncheckedCreateInput = {
    id?: string
    publication_id: string
    entity_id: string
    confidence?: number | null
    context?: string | null
  }

  export type publication_entitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: entitiesUpdateOneRequiredWithoutPublication_entitiesNestedInput
    publications?: publicationsUpdateOneRequiredWithoutPublication_entitiesNestedInput
  }

  export type publication_entitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publication_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesCreateManyInput = {
    id?: string
    publication_id: string
    entity_id: string
    confidence?: number | null
    context?: string | null
  }

  export type publication_entitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publication_id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_keywordsCreateInput = {
    keywords: keywordsCreateNestedOneWithoutPublication_keywordsInput
    publications: publicationsCreateNestedOneWithoutPublication_keywordsInput
  }

  export type publication_keywordsUncheckedCreateInput = {
    publication_id: string
    keyword_id: string
  }

  export type publication_keywordsUpdateInput = {
    keywords?: keywordsUpdateOneRequiredWithoutPublication_keywordsNestedInput
    publications?: publicationsUpdateOneRequiredWithoutPublication_keywordsNestedInput
  }

  export type publication_keywordsUncheckedUpdateInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type publication_keywordsCreateManyInput = {
    publication_id: string
    keyword_id: string
  }

  export type publication_keywordsUpdateManyMutationInput = {

  }

  export type publication_keywordsUncheckedUpdateManyInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type publication_mesh_termsCreateInput = {
    is_major_topic: boolean
    mesh_terms: mesh_termsCreateNestedOneWithoutPublication_mesh_termsInput
    publications: publicationsCreateNestedOneWithoutPublication_mesh_termsInput
  }

  export type publication_mesh_termsUncheckedCreateInput = {
    publication_id: string
    mesh_term_id: string
    is_major_topic: boolean
  }

  export type publication_mesh_termsUpdateInput = {
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
    mesh_terms?: mesh_termsUpdateOneRequiredWithoutPublication_mesh_termsNestedInput
    publications?: publicationsUpdateOneRequiredWithoutPublication_mesh_termsNestedInput
  }

  export type publication_mesh_termsUncheckedUpdateInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    mesh_term_id?: StringFieldUpdateOperationsInput | string
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publication_mesh_termsCreateManyInput = {
    publication_id: string
    mesh_term_id: string
    is_major_topic: boolean
  }

  export type publication_mesh_termsUpdateManyMutationInput = {
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publication_mesh_termsUncheckedUpdateManyInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    mesh_term_id?: StringFieldUpdateOperationsInput | string
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publicationsCreateInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUncheckedCreateInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesUncheckedCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsUncheckedCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUncheckedUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsCreateManyInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
  }

  export type publicationsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publicationsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type text_sectionsCreateInput = {
    id?: string
    section_name: string
    content: string
    section_order?: number | null
    publications: publicationsCreateNestedOneWithoutText_sectionsInput
  }

  export type text_sectionsUncheckedCreateInput = {
    id?: string
    publication_id: string
    section_name: string
    content: string
    section_order?: number | null
  }

  export type text_sectionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
    publications?: publicationsUpdateOneRequiredWithoutText_sectionsNestedInput
  }

  export type text_sectionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    publication_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type text_sectionsCreateManyInput = {
    id?: string
    publication_id: string
    section_name: string
    content: string
    section_order?: number | null
  }

  export type text_sectionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type text_sectionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    publication_id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Publication_authorsListRelationFilter = {
    every?: publication_authorsWhereInput
    some?: publication_authorsWhereInput
    none?: publication_authorsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type publication_authorsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type authorsCountOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    orcid?: SortOrder
    created_at?: SortOrder
  }

  export type authorsMaxOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    orcid?: SortOrder
    created_at?: SortOrder
  }

  export type authorsMinOrderByAggregateInput = {
    id?: SortOrder
    firstname?: SortOrder
    lastname?: SortOrder
    email?: SortOrder
    orcid?: SortOrder
    created_at?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type Publication_entitiesListRelationFilter = {
    every?: publication_entitiesWhereInput
    some?: publication_entitiesWhereInput
    none?: publication_entitiesWhereInput
  }

  export type publication_entitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type entitiesCountOrderByAggregateInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_name?: SortOrder
    normalized_name?: SortOrder
    description?: SortOrder
  }

  export type entitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_name?: SortOrder
    normalized_name?: SortOrder
    description?: SortOrder
  }

  export type entitiesMinOrderByAggregateInput = {
    id?: SortOrder
    entity_type?: SortOrder
    entity_name?: SortOrder
    normalized_name?: SortOrder
    description?: SortOrder
  }

  export type Publication_keywordsListRelationFilter = {
    every?: publication_keywordsWhereInput
    some?: publication_keywordsWhereInput
    none?: publication_keywordsWhereInput
  }

  export type publication_keywordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type keywordsCountOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    category?: SortOrder
  }

  export type keywordsMaxOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    category?: SortOrder
  }

  export type keywordsMinOrderByAggregateInput = {
    id?: SortOrder
    keyword?: SortOrder
    category?: SortOrder
  }

  export type Publication_mesh_termsListRelationFilter = {
    every?: publication_mesh_termsWhereInput
    some?: publication_mesh_termsWhereInput
    none?: publication_mesh_termsWhereInput
  }

  export type publication_mesh_termsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type mesh_termsCountOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    tree_number?: SortOrder
  }

  export type mesh_termsMaxOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    tree_number?: SortOrder
  }

  export type mesh_termsMinOrderByAggregateInput = {
    id?: SortOrder
    term?: SortOrder
    tree_number?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type AuthorsScalarRelationFilter = {
    is?: authorsWhereInput
    isNot?: authorsWhereInput
  }

  export type PublicationsScalarRelationFilter = {
    is?: publicationsWhereInput
    isNot?: publicationsWhereInput
  }

  export type publication_authorsPublication_idAuthor_idCompoundUniqueInput = {
    publication_id: string
    author_id: string
  }

  export type publication_authorsCountOrderByAggregateInput = {
    publication_id?: SortOrder
    author_id?: SortOrder
    author_order?: SortOrder
    affiliation?: SortOrder
  }

  export type publication_authorsAvgOrderByAggregateInput = {
    author_order?: SortOrder
  }

  export type publication_authorsMaxOrderByAggregateInput = {
    publication_id?: SortOrder
    author_id?: SortOrder
    author_order?: SortOrder
    affiliation?: SortOrder
  }

  export type publication_authorsMinOrderByAggregateInput = {
    publication_id?: SortOrder
    author_id?: SortOrder
    author_order?: SortOrder
    affiliation?: SortOrder
  }

  export type publication_authorsSumOrderByAggregateInput = {
    author_order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EntitiesScalarRelationFilter = {
    is?: entitiesWhereInput
    isNot?: entitiesWhereInput
  }

  export type publication_entitiesCountOrderByAggregateInput = {
    id?: SortOrder
    publication_id?: SortOrder
    entity_id?: SortOrder
    confidence?: SortOrder
    context?: SortOrder
  }

  export type publication_entitiesAvgOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type publication_entitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    publication_id?: SortOrder
    entity_id?: SortOrder
    confidence?: SortOrder
    context?: SortOrder
  }

  export type publication_entitiesMinOrderByAggregateInput = {
    id?: SortOrder
    publication_id?: SortOrder
    entity_id?: SortOrder
    confidence?: SortOrder
    context?: SortOrder
  }

  export type publication_entitiesSumOrderByAggregateInput = {
    confidence?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type KeywordsScalarRelationFilter = {
    is?: keywordsWhereInput
    isNot?: keywordsWhereInput
  }

  export type publication_keywordsPublication_idKeyword_idCompoundUniqueInput = {
    publication_id: string
    keyword_id: string
  }

  export type publication_keywordsCountOrderByAggregateInput = {
    publication_id?: SortOrder
    keyword_id?: SortOrder
  }

  export type publication_keywordsMaxOrderByAggregateInput = {
    publication_id?: SortOrder
    keyword_id?: SortOrder
  }

  export type publication_keywordsMinOrderByAggregateInput = {
    publication_id?: SortOrder
    keyword_id?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Mesh_termsScalarRelationFilter = {
    is?: mesh_termsWhereInput
    isNot?: mesh_termsWhereInput
  }

  export type publication_mesh_termsPublication_idMesh_term_idCompoundUniqueInput = {
    publication_id: string
    mesh_term_id: string
  }

  export type publication_mesh_termsCountOrderByAggregateInput = {
    publication_id?: SortOrder
    mesh_term_id?: SortOrder
    is_major_topic?: SortOrder
  }

  export type publication_mesh_termsMaxOrderByAggregateInput = {
    publication_id?: SortOrder
    mesh_term_id?: SortOrder
    is_major_topic?: SortOrder
  }

  export type publication_mesh_termsMinOrderByAggregateInput = {
    publication_id?: SortOrder
    mesh_term_id?: SortOrder
    is_major_topic?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type Text_sectionsListRelationFilter = {
    every?: text_sectionsWhereInput
    some?: text_sectionsWhereInput
    none?: text_sectionsWhereInput
  }

  export type text_sectionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type publicationsCountOrderByAggregateInput = {
    id?: SortOrder
    pmcid?: SortOrder
    pmid?: SortOrder
    doi?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    publication_date?: SortOrder
    journal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    abstract_generated?: SortOrder
    generation_type?: SortOrder
    key_findings?: SortOrder
    methodology?: SortOrder
    full_text_content?: SortOrder
  }

  export type publicationsMaxOrderByAggregateInput = {
    id?: SortOrder
    pmcid?: SortOrder
    pmid?: SortOrder
    doi?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    publication_date?: SortOrder
    journal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    abstract_generated?: SortOrder
    generation_type?: SortOrder
    key_findings?: SortOrder
    methodology?: SortOrder
    full_text_content?: SortOrder
  }

  export type publicationsMinOrderByAggregateInput = {
    id?: SortOrder
    pmcid?: SortOrder
    pmid?: SortOrder
    doi?: SortOrder
    title?: SortOrder
    abstract?: SortOrder
    publication_date?: SortOrder
    journal?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    abstract_generated?: SortOrder
    generation_type?: SortOrder
    key_findings?: SortOrder
    methodology?: SortOrder
    full_text_content?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type text_sectionsCountOrderByAggregateInput = {
    id?: SortOrder
    publication_id?: SortOrder
    section_name?: SortOrder
    content?: SortOrder
    section_order?: SortOrder
  }

  export type text_sectionsAvgOrderByAggregateInput = {
    section_order?: SortOrder
  }

  export type text_sectionsMaxOrderByAggregateInput = {
    id?: SortOrder
    publication_id?: SortOrder
    section_name?: SortOrder
    content?: SortOrder
    section_order?: SortOrder
  }

  export type text_sectionsMinOrderByAggregateInput = {
    id?: SortOrder
    publication_id?: SortOrder
    section_name?: SortOrder
    content?: SortOrder
    section_order?: SortOrder
  }

  export type text_sectionsSumOrderByAggregateInput = {
    section_order?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type publication_authorsCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<publication_authorsCreateWithoutAuthorsInput, publication_authorsUncheckedCreateWithoutAuthorsInput> | publication_authorsCreateWithoutAuthorsInput[] | publication_authorsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutAuthorsInput | publication_authorsCreateOrConnectWithoutAuthorsInput[]
    createMany?: publication_authorsCreateManyAuthorsInputEnvelope
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
  }

  export type publication_authorsUncheckedCreateNestedManyWithoutAuthorsInput = {
    create?: XOR<publication_authorsCreateWithoutAuthorsInput, publication_authorsUncheckedCreateWithoutAuthorsInput> | publication_authorsCreateWithoutAuthorsInput[] | publication_authorsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutAuthorsInput | publication_authorsCreateOrConnectWithoutAuthorsInput[]
    createMany?: publication_authorsCreateManyAuthorsInputEnvelope
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type publication_authorsUpdateManyWithoutAuthorsNestedInput = {
    create?: XOR<publication_authorsCreateWithoutAuthorsInput, publication_authorsUncheckedCreateWithoutAuthorsInput> | publication_authorsCreateWithoutAuthorsInput[] | publication_authorsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutAuthorsInput | publication_authorsCreateOrConnectWithoutAuthorsInput[]
    upsert?: publication_authorsUpsertWithWhereUniqueWithoutAuthorsInput | publication_authorsUpsertWithWhereUniqueWithoutAuthorsInput[]
    createMany?: publication_authorsCreateManyAuthorsInputEnvelope
    set?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    disconnect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    delete?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    update?: publication_authorsUpdateWithWhereUniqueWithoutAuthorsInput | publication_authorsUpdateWithWhereUniqueWithoutAuthorsInput[]
    updateMany?: publication_authorsUpdateManyWithWhereWithoutAuthorsInput | publication_authorsUpdateManyWithWhereWithoutAuthorsInput[]
    deleteMany?: publication_authorsScalarWhereInput | publication_authorsScalarWhereInput[]
  }

  export type publication_authorsUncheckedUpdateManyWithoutAuthorsNestedInput = {
    create?: XOR<publication_authorsCreateWithoutAuthorsInput, publication_authorsUncheckedCreateWithoutAuthorsInput> | publication_authorsCreateWithoutAuthorsInput[] | publication_authorsUncheckedCreateWithoutAuthorsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutAuthorsInput | publication_authorsCreateOrConnectWithoutAuthorsInput[]
    upsert?: publication_authorsUpsertWithWhereUniqueWithoutAuthorsInput | publication_authorsUpsertWithWhereUniqueWithoutAuthorsInput[]
    createMany?: publication_authorsCreateManyAuthorsInputEnvelope
    set?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    disconnect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    delete?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    update?: publication_authorsUpdateWithWhereUniqueWithoutAuthorsInput | publication_authorsUpdateWithWhereUniqueWithoutAuthorsInput[]
    updateMany?: publication_authorsUpdateManyWithWhereWithoutAuthorsInput | publication_authorsUpdateManyWithWhereWithoutAuthorsInput[]
    deleteMany?: publication_authorsScalarWhereInput | publication_authorsScalarWhereInput[]
  }

  export type publication_entitiesCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<publication_entitiesCreateWithoutEntitiesInput, publication_entitiesUncheckedCreateWithoutEntitiesInput> | publication_entitiesCreateWithoutEntitiesInput[] | publication_entitiesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutEntitiesInput | publication_entitiesCreateOrConnectWithoutEntitiesInput[]
    createMany?: publication_entitiesCreateManyEntitiesInputEnvelope
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
  }

  export type publication_entitiesUncheckedCreateNestedManyWithoutEntitiesInput = {
    create?: XOR<publication_entitiesCreateWithoutEntitiesInput, publication_entitiesUncheckedCreateWithoutEntitiesInput> | publication_entitiesCreateWithoutEntitiesInput[] | publication_entitiesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutEntitiesInput | publication_entitiesCreateOrConnectWithoutEntitiesInput[]
    createMany?: publication_entitiesCreateManyEntitiesInputEnvelope
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
  }

  export type publication_entitiesUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<publication_entitiesCreateWithoutEntitiesInput, publication_entitiesUncheckedCreateWithoutEntitiesInput> | publication_entitiesCreateWithoutEntitiesInput[] | publication_entitiesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutEntitiesInput | publication_entitiesCreateOrConnectWithoutEntitiesInput[]
    upsert?: publication_entitiesUpsertWithWhereUniqueWithoutEntitiesInput | publication_entitiesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: publication_entitiesCreateManyEntitiesInputEnvelope
    set?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    disconnect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    delete?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    update?: publication_entitiesUpdateWithWhereUniqueWithoutEntitiesInput | publication_entitiesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: publication_entitiesUpdateManyWithWhereWithoutEntitiesInput | publication_entitiesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: publication_entitiesScalarWhereInput | publication_entitiesScalarWhereInput[]
  }

  export type publication_entitiesUncheckedUpdateManyWithoutEntitiesNestedInput = {
    create?: XOR<publication_entitiesCreateWithoutEntitiesInput, publication_entitiesUncheckedCreateWithoutEntitiesInput> | publication_entitiesCreateWithoutEntitiesInput[] | publication_entitiesUncheckedCreateWithoutEntitiesInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutEntitiesInput | publication_entitiesCreateOrConnectWithoutEntitiesInput[]
    upsert?: publication_entitiesUpsertWithWhereUniqueWithoutEntitiesInput | publication_entitiesUpsertWithWhereUniqueWithoutEntitiesInput[]
    createMany?: publication_entitiesCreateManyEntitiesInputEnvelope
    set?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    disconnect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    delete?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    update?: publication_entitiesUpdateWithWhereUniqueWithoutEntitiesInput | publication_entitiesUpdateWithWhereUniqueWithoutEntitiesInput[]
    updateMany?: publication_entitiesUpdateManyWithWhereWithoutEntitiesInput | publication_entitiesUpdateManyWithWhereWithoutEntitiesInput[]
    deleteMany?: publication_entitiesScalarWhereInput | publication_entitiesScalarWhereInput[]
  }

  export type publication_keywordsCreateNestedManyWithoutKeywordsInput = {
    create?: XOR<publication_keywordsCreateWithoutKeywordsInput, publication_keywordsUncheckedCreateWithoutKeywordsInput> | publication_keywordsCreateWithoutKeywordsInput[] | publication_keywordsUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutKeywordsInput | publication_keywordsCreateOrConnectWithoutKeywordsInput[]
    createMany?: publication_keywordsCreateManyKeywordsInputEnvelope
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
  }

  export type publication_keywordsUncheckedCreateNestedManyWithoutKeywordsInput = {
    create?: XOR<publication_keywordsCreateWithoutKeywordsInput, publication_keywordsUncheckedCreateWithoutKeywordsInput> | publication_keywordsCreateWithoutKeywordsInput[] | publication_keywordsUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutKeywordsInput | publication_keywordsCreateOrConnectWithoutKeywordsInput[]
    createMany?: publication_keywordsCreateManyKeywordsInputEnvelope
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
  }

  export type publication_keywordsUpdateManyWithoutKeywordsNestedInput = {
    create?: XOR<publication_keywordsCreateWithoutKeywordsInput, publication_keywordsUncheckedCreateWithoutKeywordsInput> | publication_keywordsCreateWithoutKeywordsInput[] | publication_keywordsUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutKeywordsInput | publication_keywordsCreateOrConnectWithoutKeywordsInput[]
    upsert?: publication_keywordsUpsertWithWhereUniqueWithoutKeywordsInput | publication_keywordsUpsertWithWhereUniqueWithoutKeywordsInput[]
    createMany?: publication_keywordsCreateManyKeywordsInputEnvelope
    set?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    disconnect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    delete?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    update?: publication_keywordsUpdateWithWhereUniqueWithoutKeywordsInput | publication_keywordsUpdateWithWhereUniqueWithoutKeywordsInput[]
    updateMany?: publication_keywordsUpdateManyWithWhereWithoutKeywordsInput | publication_keywordsUpdateManyWithWhereWithoutKeywordsInput[]
    deleteMany?: publication_keywordsScalarWhereInput | publication_keywordsScalarWhereInput[]
  }

  export type publication_keywordsUncheckedUpdateManyWithoutKeywordsNestedInput = {
    create?: XOR<publication_keywordsCreateWithoutKeywordsInput, publication_keywordsUncheckedCreateWithoutKeywordsInput> | publication_keywordsCreateWithoutKeywordsInput[] | publication_keywordsUncheckedCreateWithoutKeywordsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutKeywordsInput | publication_keywordsCreateOrConnectWithoutKeywordsInput[]
    upsert?: publication_keywordsUpsertWithWhereUniqueWithoutKeywordsInput | publication_keywordsUpsertWithWhereUniqueWithoutKeywordsInput[]
    createMany?: publication_keywordsCreateManyKeywordsInputEnvelope
    set?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    disconnect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    delete?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    update?: publication_keywordsUpdateWithWhereUniqueWithoutKeywordsInput | publication_keywordsUpdateWithWhereUniqueWithoutKeywordsInput[]
    updateMany?: publication_keywordsUpdateManyWithWhereWithoutKeywordsInput | publication_keywordsUpdateManyWithWhereWithoutKeywordsInput[]
    deleteMany?: publication_keywordsScalarWhereInput | publication_keywordsScalarWhereInput[]
  }

  export type publication_mesh_termsCreateNestedManyWithoutMesh_termsInput = {
    create?: XOR<publication_mesh_termsCreateWithoutMesh_termsInput, publication_mesh_termsUncheckedCreateWithoutMesh_termsInput> | publication_mesh_termsCreateWithoutMesh_termsInput[] | publication_mesh_termsUncheckedCreateWithoutMesh_termsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutMesh_termsInput | publication_mesh_termsCreateOrConnectWithoutMesh_termsInput[]
    createMany?: publication_mesh_termsCreateManyMesh_termsInputEnvelope
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
  }

  export type publication_mesh_termsUncheckedCreateNestedManyWithoutMesh_termsInput = {
    create?: XOR<publication_mesh_termsCreateWithoutMesh_termsInput, publication_mesh_termsUncheckedCreateWithoutMesh_termsInput> | publication_mesh_termsCreateWithoutMesh_termsInput[] | publication_mesh_termsUncheckedCreateWithoutMesh_termsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutMesh_termsInput | publication_mesh_termsCreateOrConnectWithoutMesh_termsInput[]
    createMany?: publication_mesh_termsCreateManyMesh_termsInputEnvelope
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
  }

  export type publication_mesh_termsUpdateManyWithoutMesh_termsNestedInput = {
    create?: XOR<publication_mesh_termsCreateWithoutMesh_termsInput, publication_mesh_termsUncheckedCreateWithoutMesh_termsInput> | publication_mesh_termsCreateWithoutMesh_termsInput[] | publication_mesh_termsUncheckedCreateWithoutMesh_termsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutMesh_termsInput | publication_mesh_termsCreateOrConnectWithoutMesh_termsInput[]
    upsert?: publication_mesh_termsUpsertWithWhereUniqueWithoutMesh_termsInput | publication_mesh_termsUpsertWithWhereUniqueWithoutMesh_termsInput[]
    createMany?: publication_mesh_termsCreateManyMesh_termsInputEnvelope
    set?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    disconnect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    delete?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    update?: publication_mesh_termsUpdateWithWhereUniqueWithoutMesh_termsInput | publication_mesh_termsUpdateWithWhereUniqueWithoutMesh_termsInput[]
    updateMany?: publication_mesh_termsUpdateManyWithWhereWithoutMesh_termsInput | publication_mesh_termsUpdateManyWithWhereWithoutMesh_termsInput[]
    deleteMany?: publication_mesh_termsScalarWhereInput | publication_mesh_termsScalarWhereInput[]
  }

  export type publication_mesh_termsUncheckedUpdateManyWithoutMesh_termsNestedInput = {
    create?: XOR<publication_mesh_termsCreateWithoutMesh_termsInput, publication_mesh_termsUncheckedCreateWithoutMesh_termsInput> | publication_mesh_termsCreateWithoutMesh_termsInput[] | publication_mesh_termsUncheckedCreateWithoutMesh_termsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutMesh_termsInput | publication_mesh_termsCreateOrConnectWithoutMesh_termsInput[]
    upsert?: publication_mesh_termsUpsertWithWhereUniqueWithoutMesh_termsInput | publication_mesh_termsUpsertWithWhereUniqueWithoutMesh_termsInput[]
    createMany?: publication_mesh_termsCreateManyMesh_termsInputEnvelope
    set?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    disconnect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    delete?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    update?: publication_mesh_termsUpdateWithWhereUniqueWithoutMesh_termsInput | publication_mesh_termsUpdateWithWhereUniqueWithoutMesh_termsInput[]
    updateMany?: publication_mesh_termsUpdateManyWithWhereWithoutMesh_termsInput | publication_mesh_termsUpdateManyWithWhereWithoutMesh_termsInput[]
    deleteMany?: publication_mesh_termsScalarWhereInput | publication_mesh_termsScalarWhereInput[]
  }

  export type authorsCreateNestedOneWithoutPublication_authorsInput = {
    create?: XOR<authorsCreateWithoutPublication_authorsInput, authorsUncheckedCreateWithoutPublication_authorsInput>
    connectOrCreate?: authorsCreateOrConnectWithoutPublication_authorsInput
    connect?: authorsWhereUniqueInput
  }

  export type publicationsCreateNestedOneWithoutPublication_authorsInput = {
    create?: XOR<publicationsCreateWithoutPublication_authorsInput, publicationsUncheckedCreateWithoutPublication_authorsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_authorsInput
    connect?: publicationsWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type authorsUpdateOneRequiredWithoutPublication_authorsNestedInput = {
    create?: XOR<authorsCreateWithoutPublication_authorsInput, authorsUncheckedCreateWithoutPublication_authorsInput>
    connectOrCreate?: authorsCreateOrConnectWithoutPublication_authorsInput
    upsert?: authorsUpsertWithoutPublication_authorsInput
    connect?: authorsWhereUniqueInput
    update?: XOR<XOR<authorsUpdateToOneWithWhereWithoutPublication_authorsInput, authorsUpdateWithoutPublication_authorsInput>, authorsUncheckedUpdateWithoutPublication_authorsInput>
  }

  export type publicationsUpdateOneRequiredWithoutPublication_authorsNestedInput = {
    create?: XOR<publicationsCreateWithoutPublication_authorsInput, publicationsUncheckedCreateWithoutPublication_authorsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_authorsInput
    upsert?: publicationsUpsertWithoutPublication_authorsInput
    connect?: publicationsWhereUniqueInput
    update?: XOR<XOR<publicationsUpdateToOneWithWhereWithoutPublication_authorsInput, publicationsUpdateWithoutPublication_authorsInput>, publicationsUncheckedUpdateWithoutPublication_authorsInput>
  }

  export type entitiesCreateNestedOneWithoutPublication_entitiesInput = {
    create?: XOR<entitiesCreateWithoutPublication_entitiesInput, entitiesUncheckedCreateWithoutPublication_entitiesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutPublication_entitiesInput
    connect?: entitiesWhereUniqueInput
  }

  export type publicationsCreateNestedOneWithoutPublication_entitiesInput = {
    create?: XOR<publicationsCreateWithoutPublication_entitiesInput, publicationsUncheckedCreateWithoutPublication_entitiesInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_entitiesInput
    connect?: publicationsWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type entitiesUpdateOneRequiredWithoutPublication_entitiesNestedInput = {
    create?: XOR<entitiesCreateWithoutPublication_entitiesInput, entitiesUncheckedCreateWithoutPublication_entitiesInput>
    connectOrCreate?: entitiesCreateOrConnectWithoutPublication_entitiesInput
    upsert?: entitiesUpsertWithoutPublication_entitiesInput
    connect?: entitiesWhereUniqueInput
    update?: XOR<XOR<entitiesUpdateToOneWithWhereWithoutPublication_entitiesInput, entitiesUpdateWithoutPublication_entitiesInput>, entitiesUncheckedUpdateWithoutPublication_entitiesInput>
  }

  export type publicationsUpdateOneRequiredWithoutPublication_entitiesNestedInput = {
    create?: XOR<publicationsCreateWithoutPublication_entitiesInput, publicationsUncheckedCreateWithoutPublication_entitiesInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_entitiesInput
    upsert?: publicationsUpsertWithoutPublication_entitiesInput
    connect?: publicationsWhereUniqueInput
    update?: XOR<XOR<publicationsUpdateToOneWithWhereWithoutPublication_entitiesInput, publicationsUpdateWithoutPublication_entitiesInput>, publicationsUncheckedUpdateWithoutPublication_entitiesInput>
  }

  export type keywordsCreateNestedOneWithoutPublication_keywordsInput = {
    create?: XOR<keywordsCreateWithoutPublication_keywordsInput, keywordsUncheckedCreateWithoutPublication_keywordsInput>
    connectOrCreate?: keywordsCreateOrConnectWithoutPublication_keywordsInput
    connect?: keywordsWhereUniqueInput
  }

  export type publicationsCreateNestedOneWithoutPublication_keywordsInput = {
    create?: XOR<publicationsCreateWithoutPublication_keywordsInput, publicationsUncheckedCreateWithoutPublication_keywordsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_keywordsInput
    connect?: publicationsWhereUniqueInput
  }

  export type keywordsUpdateOneRequiredWithoutPublication_keywordsNestedInput = {
    create?: XOR<keywordsCreateWithoutPublication_keywordsInput, keywordsUncheckedCreateWithoutPublication_keywordsInput>
    connectOrCreate?: keywordsCreateOrConnectWithoutPublication_keywordsInput
    upsert?: keywordsUpsertWithoutPublication_keywordsInput
    connect?: keywordsWhereUniqueInput
    update?: XOR<XOR<keywordsUpdateToOneWithWhereWithoutPublication_keywordsInput, keywordsUpdateWithoutPublication_keywordsInput>, keywordsUncheckedUpdateWithoutPublication_keywordsInput>
  }

  export type publicationsUpdateOneRequiredWithoutPublication_keywordsNestedInput = {
    create?: XOR<publicationsCreateWithoutPublication_keywordsInput, publicationsUncheckedCreateWithoutPublication_keywordsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_keywordsInput
    upsert?: publicationsUpsertWithoutPublication_keywordsInput
    connect?: publicationsWhereUniqueInput
    update?: XOR<XOR<publicationsUpdateToOneWithWhereWithoutPublication_keywordsInput, publicationsUpdateWithoutPublication_keywordsInput>, publicationsUncheckedUpdateWithoutPublication_keywordsInput>
  }

  export type mesh_termsCreateNestedOneWithoutPublication_mesh_termsInput = {
    create?: XOR<mesh_termsCreateWithoutPublication_mesh_termsInput, mesh_termsUncheckedCreateWithoutPublication_mesh_termsInput>
    connectOrCreate?: mesh_termsCreateOrConnectWithoutPublication_mesh_termsInput
    connect?: mesh_termsWhereUniqueInput
  }

  export type publicationsCreateNestedOneWithoutPublication_mesh_termsInput = {
    create?: XOR<publicationsCreateWithoutPublication_mesh_termsInput, publicationsUncheckedCreateWithoutPublication_mesh_termsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_mesh_termsInput
    connect?: publicationsWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type mesh_termsUpdateOneRequiredWithoutPublication_mesh_termsNestedInput = {
    create?: XOR<mesh_termsCreateWithoutPublication_mesh_termsInput, mesh_termsUncheckedCreateWithoutPublication_mesh_termsInput>
    connectOrCreate?: mesh_termsCreateOrConnectWithoutPublication_mesh_termsInput
    upsert?: mesh_termsUpsertWithoutPublication_mesh_termsInput
    connect?: mesh_termsWhereUniqueInput
    update?: XOR<XOR<mesh_termsUpdateToOneWithWhereWithoutPublication_mesh_termsInput, mesh_termsUpdateWithoutPublication_mesh_termsInput>, mesh_termsUncheckedUpdateWithoutPublication_mesh_termsInput>
  }

  export type publicationsUpdateOneRequiredWithoutPublication_mesh_termsNestedInput = {
    create?: XOR<publicationsCreateWithoutPublication_mesh_termsInput, publicationsUncheckedCreateWithoutPublication_mesh_termsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutPublication_mesh_termsInput
    upsert?: publicationsUpsertWithoutPublication_mesh_termsInput
    connect?: publicationsWhereUniqueInput
    update?: XOR<XOR<publicationsUpdateToOneWithWhereWithoutPublication_mesh_termsInput, publicationsUpdateWithoutPublication_mesh_termsInput>, publicationsUncheckedUpdateWithoutPublication_mesh_termsInput>
  }

  export type publication_authorsCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_authorsCreateWithoutPublicationsInput, publication_authorsUncheckedCreateWithoutPublicationsInput> | publication_authorsCreateWithoutPublicationsInput[] | publication_authorsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutPublicationsInput | publication_authorsCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_authorsCreateManyPublicationsInputEnvelope
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
  }

  export type publication_entitiesCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_entitiesCreateWithoutPublicationsInput, publication_entitiesUncheckedCreateWithoutPublicationsInput> | publication_entitiesCreateWithoutPublicationsInput[] | publication_entitiesUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutPublicationsInput | publication_entitiesCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_entitiesCreateManyPublicationsInputEnvelope
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
  }

  export type publication_keywordsCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_keywordsCreateWithoutPublicationsInput, publication_keywordsUncheckedCreateWithoutPublicationsInput> | publication_keywordsCreateWithoutPublicationsInput[] | publication_keywordsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutPublicationsInput | publication_keywordsCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_keywordsCreateManyPublicationsInputEnvelope
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
  }

  export type publication_mesh_termsCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_mesh_termsCreateWithoutPublicationsInput, publication_mesh_termsUncheckedCreateWithoutPublicationsInput> | publication_mesh_termsCreateWithoutPublicationsInput[] | publication_mesh_termsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutPublicationsInput | publication_mesh_termsCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_mesh_termsCreateManyPublicationsInputEnvelope
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
  }

  export type text_sectionsCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<text_sectionsCreateWithoutPublicationsInput, text_sectionsUncheckedCreateWithoutPublicationsInput> | text_sectionsCreateWithoutPublicationsInput[] | text_sectionsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: text_sectionsCreateOrConnectWithoutPublicationsInput | text_sectionsCreateOrConnectWithoutPublicationsInput[]
    createMany?: text_sectionsCreateManyPublicationsInputEnvelope
    connect?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
  }

  export type publication_authorsUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_authorsCreateWithoutPublicationsInput, publication_authorsUncheckedCreateWithoutPublicationsInput> | publication_authorsCreateWithoutPublicationsInput[] | publication_authorsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutPublicationsInput | publication_authorsCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_authorsCreateManyPublicationsInputEnvelope
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
  }

  export type publication_entitiesUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_entitiesCreateWithoutPublicationsInput, publication_entitiesUncheckedCreateWithoutPublicationsInput> | publication_entitiesCreateWithoutPublicationsInput[] | publication_entitiesUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutPublicationsInput | publication_entitiesCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_entitiesCreateManyPublicationsInputEnvelope
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
  }

  export type publication_keywordsUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_keywordsCreateWithoutPublicationsInput, publication_keywordsUncheckedCreateWithoutPublicationsInput> | publication_keywordsCreateWithoutPublicationsInput[] | publication_keywordsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutPublicationsInput | publication_keywordsCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_keywordsCreateManyPublicationsInputEnvelope
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
  }

  export type publication_mesh_termsUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<publication_mesh_termsCreateWithoutPublicationsInput, publication_mesh_termsUncheckedCreateWithoutPublicationsInput> | publication_mesh_termsCreateWithoutPublicationsInput[] | publication_mesh_termsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutPublicationsInput | publication_mesh_termsCreateOrConnectWithoutPublicationsInput[]
    createMany?: publication_mesh_termsCreateManyPublicationsInputEnvelope
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
  }

  export type text_sectionsUncheckedCreateNestedManyWithoutPublicationsInput = {
    create?: XOR<text_sectionsCreateWithoutPublicationsInput, text_sectionsUncheckedCreateWithoutPublicationsInput> | text_sectionsCreateWithoutPublicationsInput[] | text_sectionsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: text_sectionsCreateOrConnectWithoutPublicationsInput | text_sectionsCreateOrConnectWithoutPublicationsInput[]
    createMany?: text_sectionsCreateManyPublicationsInputEnvelope
    connect?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type publication_authorsUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_authorsCreateWithoutPublicationsInput, publication_authorsUncheckedCreateWithoutPublicationsInput> | publication_authorsCreateWithoutPublicationsInput[] | publication_authorsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutPublicationsInput | publication_authorsCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_authorsUpsertWithWhereUniqueWithoutPublicationsInput | publication_authorsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_authorsCreateManyPublicationsInputEnvelope
    set?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    disconnect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    delete?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    update?: publication_authorsUpdateWithWhereUniqueWithoutPublicationsInput | publication_authorsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_authorsUpdateManyWithWhereWithoutPublicationsInput | publication_authorsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_authorsScalarWhereInput | publication_authorsScalarWhereInput[]
  }

  export type publication_entitiesUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_entitiesCreateWithoutPublicationsInput, publication_entitiesUncheckedCreateWithoutPublicationsInput> | publication_entitiesCreateWithoutPublicationsInput[] | publication_entitiesUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutPublicationsInput | publication_entitiesCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_entitiesUpsertWithWhereUniqueWithoutPublicationsInput | publication_entitiesUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_entitiesCreateManyPublicationsInputEnvelope
    set?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    disconnect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    delete?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    update?: publication_entitiesUpdateWithWhereUniqueWithoutPublicationsInput | publication_entitiesUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_entitiesUpdateManyWithWhereWithoutPublicationsInput | publication_entitiesUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_entitiesScalarWhereInput | publication_entitiesScalarWhereInput[]
  }

  export type publication_keywordsUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_keywordsCreateWithoutPublicationsInput, publication_keywordsUncheckedCreateWithoutPublicationsInput> | publication_keywordsCreateWithoutPublicationsInput[] | publication_keywordsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutPublicationsInput | publication_keywordsCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_keywordsUpsertWithWhereUniqueWithoutPublicationsInput | publication_keywordsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_keywordsCreateManyPublicationsInputEnvelope
    set?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    disconnect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    delete?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    update?: publication_keywordsUpdateWithWhereUniqueWithoutPublicationsInput | publication_keywordsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_keywordsUpdateManyWithWhereWithoutPublicationsInput | publication_keywordsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_keywordsScalarWhereInput | publication_keywordsScalarWhereInput[]
  }

  export type publication_mesh_termsUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_mesh_termsCreateWithoutPublicationsInput, publication_mesh_termsUncheckedCreateWithoutPublicationsInput> | publication_mesh_termsCreateWithoutPublicationsInput[] | publication_mesh_termsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutPublicationsInput | publication_mesh_termsCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_mesh_termsUpsertWithWhereUniqueWithoutPublicationsInput | publication_mesh_termsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_mesh_termsCreateManyPublicationsInputEnvelope
    set?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    disconnect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    delete?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    update?: publication_mesh_termsUpdateWithWhereUniqueWithoutPublicationsInput | publication_mesh_termsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_mesh_termsUpdateManyWithWhereWithoutPublicationsInput | publication_mesh_termsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_mesh_termsScalarWhereInput | publication_mesh_termsScalarWhereInput[]
  }

  export type text_sectionsUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<text_sectionsCreateWithoutPublicationsInput, text_sectionsUncheckedCreateWithoutPublicationsInput> | text_sectionsCreateWithoutPublicationsInput[] | text_sectionsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: text_sectionsCreateOrConnectWithoutPublicationsInput | text_sectionsCreateOrConnectWithoutPublicationsInput[]
    upsert?: text_sectionsUpsertWithWhereUniqueWithoutPublicationsInput | text_sectionsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: text_sectionsCreateManyPublicationsInputEnvelope
    set?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    disconnect?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    delete?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    connect?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    update?: text_sectionsUpdateWithWhereUniqueWithoutPublicationsInput | text_sectionsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: text_sectionsUpdateManyWithWhereWithoutPublicationsInput | text_sectionsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: text_sectionsScalarWhereInput | text_sectionsScalarWhereInput[]
  }

  export type publication_authorsUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_authorsCreateWithoutPublicationsInput, publication_authorsUncheckedCreateWithoutPublicationsInput> | publication_authorsCreateWithoutPublicationsInput[] | publication_authorsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_authorsCreateOrConnectWithoutPublicationsInput | publication_authorsCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_authorsUpsertWithWhereUniqueWithoutPublicationsInput | publication_authorsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_authorsCreateManyPublicationsInputEnvelope
    set?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    disconnect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    delete?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    connect?: publication_authorsWhereUniqueInput | publication_authorsWhereUniqueInput[]
    update?: publication_authorsUpdateWithWhereUniqueWithoutPublicationsInput | publication_authorsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_authorsUpdateManyWithWhereWithoutPublicationsInput | publication_authorsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_authorsScalarWhereInput | publication_authorsScalarWhereInput[]
  }

  export type publication_entitiesUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_entitiesCreateWithoutPublicationsInput, publication_entitiesUncheckedCreateWithoutPublicationsInput> | publication_entitiesCreateWithoutPublicationsInput[] | publication_entitiesUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_entitiesCreateOrConnectWithoutPublicationsInput | publication_entitiesCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_entitiesUpsertWithWhereUniqueWithoutPublicationsInput | publication_entitiesUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_entitiesCreateManyPublicationsInputEnvelope
    set?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    disconnect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    delete?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    connect?: publication_entitiesWhereUniqueInput | publication_entitiesWhereUniqueInput[]
    update?: publication_entitiesUpdateWithWhereUniqueWithoutPublicationsInput | publication_entitiesUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_entitiesUpdateManyWithWhereWithoutPublicationsInput | publication_entitiesUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_entitiesScalarWhereInput | publication_entitiesScalarWhereInput[]
  }

  export type publication_keywordsUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_keywordsCreateWithoutPublicationsInput, publication_keywordsUncheckedCreateWithoutPublicationsInput> | publication_keywordsCreateWithoutPublicationsInput[] | publication_keywordsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_keywordsCreateOrConnectWithoutPublicationsInput | publication_keywordsCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_keywordsUpsertWithWhereUniqueWithoutPublicationsInput | publication_keywordsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_keywordsCreateManyPublicationsInputEnvelope
    set?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    disconnect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    delete?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    connect?: publication_keywordsWhereUniqueInput | publication_keywordsWhereUniqueInput[]
    update?: publication_keywordsUpdateWithWhereUniqueWithoutPublicationsInput | publication_keywordsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_keywordsUpdateManyWithWhereWithoutPublicationsInput | publication_keywordsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_keywordsScalarWhereInput | publication_keywordsScalarWhereInput[]
  }

  export type publication_mesh_termsUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<publication_mesh_termsCreateWithoutPublicationsInput, publication_mesh_termsUncheckedCreateWithoutPublicationsInput> | publication_mesh_termsCreateWithoutPublicationsInput[] | publication_mesh_termsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: publication_mesh_termsCreateOrConnectWithoutPublicationsInput | publication_mesh_termsCreateOrConnectWithoutPublicationsInput[]
    upsert?: publication_mesh_termsUpsertWithWhereUniqueWithoutPublicationsInput | publication_mesh_termsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: publication_mesh_termsCreateManyPublicationsInputEnvelope
    set?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    disconnect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    delete?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    connect?: publication_mesh_termsWhereUniqueInput | publication_mesh_termsWhereUniqueInput[]
    update?: publication_mesh_termsUpdateWithWhereUniqueWithoutPublicationsInput | publication_mesh_termsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: publication_mesh_termsUpdateManyWithWhereWithoutPublicationsInput | publication_mesh_termsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: publication_mesh_termsScalarWhereInput | publication_mesh_termsScalarWhereInput[]
  }

  export type text_sectionsUncheckedUpdateManyWithoutPublicationsNestedInput = {
    create?: XOR<text_sectionsCreateWithoutPublicationsInput, text_sectionsUncheckedCreateWithoutPublicationsInput> | text_sectionsCreateWithoutPublicationsInput[] | text_sectionsUncheckedCreateWithoutPublicationsInput[]
    connectOrCreate?: text_sectionsCreateOrConnectWithoutPublicationsInput | text_sectionsCreateOrConnectWithoutPublicationsInput[]
    upsert?: text_sectionsUpsertWithWhereUniqueWithoutPublicationsInput | text_sectionsUpsertWithWhereUniqueWithoutPublicationsInput[]
    createMany?: text_sectionsCreateManyPublicationsInputEnvelope
    set?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    disconnect?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    delete?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    connect?: text_sectionsWhereUniqueInput | text_sectionsWhereUniqueInput[]
    update?: text_sectionsUpdateWithWhereUniqueWithoutPublicationsInput | text_sectionsUpdateWithWhereUniqueWithoutPublicationsInput[]
    updateMany?: text_sectionsUpdateManyWithWhereWithoutPublicationsInput | text_sectionsUpdateManyWithWhereWithoutPublicationsInput[]
    deleteMany?: text_sectionsScalarWhereInput | text_sectionsScalarWhereInput[]
  }

  export type publicationsCreateNestedOneWithoutText_sectionsInput = {
    create?: XOR<publicationsCreateWithoutText_sectionsInput, publicationsUncheckedCreateWithoutText_sectionsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutText_sectionsInput
    connect?: publicationsWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type publicationsUpdateOneRequiredWithoutText_sectionsNestedInput = {
    create?: XOR<publicationsCreateWithoutText_sectionsInput, publicationsUncheckedCreateWithoutText_sectionsInput>
    connectOrCreate?: publicationsCreateOrConnectWithoutText_sectionsInput
    upsert?: publicationsUpsertWithoutText_sectionsInput
    connect?: publicationsWhereUniqueInput
    update?: XOR<XOR<publicationsUpdateToOneWithWhereWithoutText_sectionsInput, publicationsUpdateWithoutText_sectionsInput>, publicationsUncheckedUpdateWithoutText_sectionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type publication_authorsCreateWithoutAuthorsInput = {
    author_order: number
    affiliation?: string | null
    publications: publicationsCreateNestedOneWithoutPublication_authorsInput
  }

  export type publication_authorsUncheckedCreateWithoutAuthorsInput = {
    publication_id: string
    author_order: number
    affiliation?: string | null
  }

  export type publication_authorsCreateOrConnectWithoutAuthorsInput = {
    where: publication_authorsWhereUniqueInput
    create: XOR<publication_authorsCreateWithoutAuthorsInput, publication_authorsUncheckedCreateWithoutAuthorsInput>
  }

  export type publication_authorsCreateManyAuthorsInputEnvelope = {
    data: publication_authorsCreateManyAuthorsInput | publication_authorsCreateManyAuthorsInput[]
    skipDuplicates?: boolean
  }

  export type publication_authorsUpsertWithWhereUniqueWithoutAuthorsInput = {
    where: publication_authorsWhereUniqueInput
    update: XOR<publication_authorsUpdateWithoutAuthorsInput, publication_authorsUncheckedUpdateWithoutAuthorsInput>
    create: XOR<publication_authorsCreateWithoutAuthorsInput, publication_authorsUncheckedCreateWithoutAuthorsInput>
  }

  export type publication_authorsUpdateWithWhereUniqueWithoutAuthorsInput = {
    where: publication_authorsWhereUniqueInput
    data: XOR<publication_authorsUpdateWithoutAuthorsInput, publication_authorsUncheckedUpdateWithoutAuthorsInput>
  }

  export type publication_authorsUpdateManyWithWhereWithoutAuthorsInput = {
    where: publication_authorsScalarWhereInput
    data: XOR<publication_authorsUpdateManyMutationInput, publication_authorsUncheckedUpdateManyWithoutAuthorsInput>
  }

  export type publication_authorsScalarWhereInput = {
    AND?: publication_authorsScalarWhereInput | publication_authorsScalarWhereInput[]
    OR?: publication_authorsScalarWhereInput[]
    NOT?: publication_authorsScalarWhereInput | publication_authorsScalarWhereInput[]
    publication_id?: UuidFilter<"publication_authors"> | string
    author_id?: UuidFilter<"publication_authors"> | string
    author_order?: IntFilter<"publication_authors"> | number
    affiliation?: StringNullableFilter<"publication_authors"> | string | null
  }

  export type publication_entitiesCreateWithoutEntitiesInput = {
    id?: string
    confidence?: number | null
    context?: string | null
    publications: publicationsCreateNestedOneWithoutPublication_entitiesInput
  }

  export type publication_entitiesUncheckedCreateWithoutEntitiesInput = {
    id?: string
    publication_id: string
    confidence?: number | null
    context?: string | null
  }

  export type publication_entitiesCreateOrConnectWithoutEntitiesInput = {
    where: publication_entitiesWhereUniqueInput
    create: XOR<publication_entitiesCreateWithoutEntitiesInput, publication_entitiesUncheckedCreateWithoutEntitiesInput>
  }

  export type publication_entitiesCreateManyEntitiesInputEnvelope = {
    data: publication_entitiesCreateManyEntitiesInput | publication_entitiesCreateManyEntitiesInput[]
    skipDuplicates?: boolean
  }

  export type publication_entitiesUpsertWithWhereUniqueWithoutEntitiesInput = {
    where: publication_entitiesWhereUniqueInput
    update: XOR<publication_entitiesUpdateWithoutEntitiesInput, publication_entitiesUncheckedUpdateWithoutEntitiesInput>
    create: XOR<publication_entitiesCreateWithoutEntitiesInput, publication_entitiesUncheckedCreateWithoutEntitiesInput>
  }

  export type publication_entitiesUpdateWithWhereUniqueWithoutEntitiesInput = {
    where: publication_entitiesWhereUniqueInput
    data: XOR<publication_entitiesUpdateWithoutEntitiesInput, publication_entitiesUncheckedUpdateWithoutEntitiesInput>
  }

  export type publication_entitiesUpdateManyWithWhereWithoutEntitiesInput = {
    where: publication_entitiesScalarWhereInput
    data: XOR<publication_entitiesUpdateManyMutationInput, publication_entitiesUncheckedUpdateManyWithoutEntitiesInput>
  }

  export type publication_entitiesScalarWhereInput = {
    AND?: publication_entitiesScalarWhereInput | publication_entitiesScalarWhereInput[]
    OR?: publication_entitiesScalarWhereInput[]
    NOT?: publication_entitiesScalarWhereInput | publication_entitiesScalarWhereInput[]
    id?: UuidFilter<"publication_entities"> | string
    publication_id?: UuidFilter<"publication_entities"> | string
    entity_id?: UuidFilter<"publication_entities"> | string
    confidence?: FloatNullableFilter<"publication_entities"> | number | null
    context?: StringNullableFilter<"publication_entities"> | string | null
  }

  export type publication_keywordsCreateWithoutKeywordsInput = {
    publications: publicationsCreateNestedOneWithoutPublication_keywordsInput
  }

  export type publication_keywordsUncheckedCreateWithoutKeywordsInput = {
    publication_id: string
  }

  export type publication_keywordsCreateOrConnectWithoutKeywordsInput = {
    where: publication_keywordsWhereUniqueInput
    create: XOR<publication_keywordsCreateWithoutKeywordsInput, publication_keywordsUncheckedCreateWithoutKeywordsInput>
  }

  export type publication_keywordsCreateManyKeywordsInputEnvelope = {
    data: publication_keywordsCreateManyKeywordsInput | publication_keywordsCreateManyKeywordsInput[]
    skipDuplicates?: boolean
  }

  export type publication_keywordsUpsertWithWhereUniqueWithoutKeywordsInput = {
    where: publication_keywordsWhereUniqueInput
    update: XOR<publication_keywordsUpdateWithoutKeywordsInput, publication_keywordsUncheckedUpdateWithoutKeywordsInput>
    create: XOR<publication_keywordsCreateWithoutKeywordsInput, publication_keywordsUncheckedCreateWithoutKeywordsInput>
  }

  export type publication_keywordsUpdateWithWhereUniqueWithoutKeywordsInput = {
    where: publication_keywordsWhereUniqueInput
    data: XOR<publication_keywordsUpdateWithoutKeywordsInput, publication_keywordsUncheckedUpdateWithoutKeywordsInput>
  }

  export type publication_keywordsUpdateManyWithWhereWithoutKeywordsInput = {
    where: publication_keywordsScalarWhereInput
    data: XOR<publication_keywordsUpdateManyMutationInput, publication_keywordsUncheckedUpdateManyWithoutKeywordsInput>
  }

  export type publication_keywordsScalarWhereInput = {
    AND?: publication_keywordsScalarWhereInput | publication_keywordsScalarWhereInput[]
    OR?: publication_keywordsScalarWhereInput[]
    NOT?: publication_keywordsScalarWhereInput | publication_keywordsScalarWhereInput[]
    publication_id?: UuidFilter<"publication_keywords"> | string
    keyword_id?: UuidFilter<"publication_keywords"> | string
  }

  export type publication_mesh_termsCreateWithoutMesh_termsInput = {
    is_major_topic: boolean
    publications: publicationsCreateNestedOneWithoutPublication_mesh_termsInput
  }

  export type publication_mesh_termsUncheckedCreateWithoutMesh_termsInput = {
    publication_id: string
    is_major_topic: boolean
  }

  export type publication_mesh_termsCreateOrConnectWithoutMesh_termsInput = {
    where: publication_mesh_termsWhereUniqueInput
    create: XOR<publication_mesh_termsCreateWithoutMesh_termsInput, publication_mesh_termsUncheckedCreateWithoutMesh_termsInput>
  }

  export type publication_mesh_termsCreateManyMesh_termsInputEnvelope = {
    data: publication_mesh_termsCreateManyMesh_termsInput | publication_mesh_termsCreateManyMesh_termsInput[]
    skipDuplicates?: boolean
  }

  export type publication_mesh_termsUpsertWithWhereUniqueWithoutMesh_termsInput = {
    where: publication_mesh_termsWhereUniqueInput
    update: XOR<publication_mesh_termsUpdateWithoutMesh_termsInput, publication_mesh_termsUncheckedUpdateWithoutMesh_termsInput>
    create: XOR<publication_mesh_termsCreateWithoutMesh_termsInput, publication_mesh_termsUncheckedCreateWithoutMesh_termsInput>
  }

  export type publication_mesh_termsUpdateWithWhereUniqueWithoutMesh_termsInput = {
    where: publication_mesh_termsWhereUniqueInput
    data: XOR<publication_mesh_termsUpdateWithoutMesh_termsInput, publication_mesh_termsUncheckedUpdateWithoutMesh_termsInput>
  }

  export type publication_mesh_termsUpdateManyWithWhereWithoutMesh_termsInput = {
    where: publication_mesh_termsScalarWhereInput
    data: XOR<publication_mesh_termsUpdateManyMutationInput, publication_mesh_termsUncheckedUpdateManyWithoutMesh_termsInput>
  }

  export type publication_mesh_termsScalarWhereInput = {
    AND?: publication_mesh_termsScalarWhereInput | publication_mesh_termsScalarWhereInput[]
    OR?: publication_mesh_termsScalarWhereInput[]
    NOT?: publication_mesh_termsScalarWhereInput | publication_mesh_termsScalarWhereInput[]
    publication_id?: UuidFilter<"publication_mesh_terms"> | string
    mesh_term_id?: UuidFilter<"publication_mesh_terms"> | string
    is_major_topic?: BoolFilter<"publication_mesh_terms"> | boolean
  }

  export type authorsCreateWithoutPublication_authorsInput = {
    id?: string
    firstname?: string | null
    lastname: string
    email?: string | null
    orcid?: string | null
    created_at: Date | string
  }

  export type authorsUncheckedCreateWithoutPublication_authorsInput = {
    id?: string
    firstname?: string | null
    lastname: string
    email?: string | null
    orcid?: string | null
    created_at: Date | string
  }

  export type authorsCreateOrConnectWithoutPublication_authorsInput = {
    where: authorsWhereUniqueInput
    create: XOR<authorsCreateWithoutPublication_authorsInput, authorsUncheckedCreateWithoutPublication_authorsInput>
  }

  export type publicationsCreateWithoutPublication_authorsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_entities?: publication_entitiesCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUncheckedCreateWithoutPublication_authorsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_entities?: publication_entitiesUncheckedCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsUncheckedCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsCreateOrConnectWithoutPublication_authorsInput = {
    where: publicationsWhereUniqueInput
    create: XOR<publicationsCreateWithoutPublication_authorsInput, publicationsUncheckedCreateWithoutPublication_authorsInput>
  }

  export type authorsUpsertWithoutPublication_authorsInput = {
    update: XOR<authorsUpdateWithoutPublication_authorsInput, authorsUncheckedUpdateWithoutPublication_authorsInput>
    create: XOR<authorsCreateWithoutPublication_authorsInput, authorsUncheckedCreateWithoutPublication_authorsInput>
    where?: authorsWhereInput
  }

  export type authorsUpdateToOneWithWhereWithoutPublication_authorsInput = {
    where?: authorsWhereInput
    data: XOR<authorsUpdateWithoutPublication_authorsInput, authorsUncheckedUpdateWithoutPublication_authorsInput>
  }

  export type authorsUpdateWithoutPublication_authorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orcid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type authorsUncheckedUpdateWithoutPublication_authorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstname?: NullableStringFieldUpdateOperationsInput | string | null
    lastname?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    orcid?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type publicationsUpsertWithoutPublication_authorsInput = {
    update: XOR<publicationsUpdateWithoutPublication_authorsInput, publicationsUncheckedUpdateWithoutPublication_authorsInput>
    create: XOR<publicationsCreateWithoutPublication_authorsInput, publicationsUncheckedCreateWithoutPublication_authorsInput>
    where?: publicationsWhereInput
  }

  export type publicationsUpdateToOneWithWhereWithoutPublication_authorsInput = {
    where?: publicationsWhereInput
    data: XOR<publicationsUpdateWithoutPublication_authorsInput, publicationsUncheckedUpdateWithoutPublication_authorsInput>
  }

  export type publicationsUpdateWithoutPublication_authorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_entities?: publication_entitiesUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsUncheckedUpdateWithoutPublication_authorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_entities?: publication_entitiesUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUncheckedUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type entitiesCreateWithoutPublication_entitiesInput = {
    id?: string
    entity_type: string
    entity_name: string
    normalized_name?: string | null
    description?: string | null
  }

  export type entitiesUncheckedCreateWithoutPublication_entitiesInput = {
    id?: string
    entity_type: string
    entity_name: string
    normalized_name?: string | null
    description?: string | null
  }

  export type entitiesCreateOrConnectWithoutPublication_entitiesInput = {
    where: entitiesWhereUniqueInput
    create: XOR<entitiesCreateWithoutPublication_entitiesInput, entitiesUncheckedCreateWithoutPublication_entitiesInput>
  }

  export type publicationsCreateWithoutPublication_entitiesInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUncheckedCreateWithoutPublication_entitiesInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsUncheckedCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsCreateOrConnectWithoutPublication_entitiesInput = {
    where: publicationsWhereUniqueInput
    create: XOR<publicationsCreateWithoutPublication_entitiesInput, publicationsUncheckedCreateWithoutPublication_entitiesInput>
  }

  export type entitiesUpsertWithoutPublication_entitiesInput = {
    update: XOR<entitiesUpdateWithoutPublication_entitiesInput, entitiesUncheckedUpdateWithoutPublication_entitiesInput>
    create: XOR<entitiesCreateWithoutPublication_entitiesInput, entitiesUncheckedCreateWithoutPublication_entitiesInput>
    where?: entitiesWhereInput
  }

  export type entitiesUpdateToOneWithWhereWithoutPublication_entitiesInput = {
    where?: entitiesWhereInput
    data: XOR<entitiesUpdateWithoutPublication_entitiesInput, entitiesUncheckedUpdateWithoutPublication_entitiesInput>
  }

  export type entitiesUpdateWithoutPublication_entitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_name?: StringFieldUpdateOperationsInput | string
    normalized_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type entitiesUncheckedUpdateWithoutPublication_entitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_type?: StringFieldUpdateOperationsInput | string
    entity_name?: StringFieldUpdateOperationsInput | string
    normalized_name?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publicationsUpsertWithoutPublication_entitiesInput = {
    update: XOR<publicationsUpdateWithoutPublication_entitiesInput, publicationsUncheckedUpdateWithoutPublication_entitiesInput>
    create: XOR<publicationsCreateWithoutPublication_entitiesInput, publicationsUncheckedCreateWithoutPublication_entitiesInput>
    where?: publicationsWhereInput
  }

  export type publicationsUpdateToOneWithWhereWithoutPublication_entitiesInput = {
    where?: publicationsWhereInput
    data: XOR<publicationsUpdateWithoutPublication_entitiesInput, publicationsUncheckedUpdateWithoutPublication_entitiesInput>
  }

  export type publicationsUpdateWithoutPublication_entitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsUncheckedUpdateWithoutPublication_entitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUncheckedUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type keywordsCreateWithoutPublication_keywordsInput = {
    id?: string
    keyword: string
    category?: string | null
  }

  export type keywordsUncheckedCreateWithoutPublication_keywordsInput = {
    id?: string
    keyword: string
    category?: string | null
  }

  export type keywordsCreateOrConnectWithoutPublication_keywordsInput = {
    where: keywordsWhereUniqueInput
    create: XOR<keywordsCreateWithoutPublication_keywordsInput, keywordsUncheckedCreateWithoutPublication_keywordsInput>
  }

  export type publicationsCreateWithoutPublication_keywordsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUncheckedCreateWithoutPublication_keywordsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesUncheckedCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsUncheckedCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsCreateOrConnectWithoutPublication_keywordsInput = {
    where: publicationsWhereUniqueInput
    create: XOR<publicationsCreateWithoutPublication_keywordsInput, publicationsUncheckedCreateWithoutPublication_keywordsInput>
  }

  export type keywordsUpsertWithoutPublication_keywordsInput = {
    update: XOR<keywordsUpdateWithoutPublication_keywordsInput, keywordsUncheckedUpdateWithoutPublication_keywordsInput>
    create: XOR<keywordsCreateWithoutPublication_keywordsInput, keywordsUncheckedCreateWithoutPublication_keywordsInput>
    where?: keywordsWhereInput
  }

  export type keywordsUpdateToOneWithWhereWithoutPublication_keywordsInput = {
    where?: keywordsWhereInput
    data: XOR<keywordsUpdateWithoutPublication_keywordsInput, keywordsUncheckedUpdateWithoutPublication_keywordsInput>
  }

  export type keywordsUpdateWithoutPublication_keywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type keywordsUncheckedUpdateWithoutPublication_keywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    keyword?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publicationsUpsertWithoutPublication_keywordsInput = {
    update: XOR<publicationsUpdateWithoutPublication_keywordsInput, publicationsUncheckedUpdateWithoutPublication_keywordsInput>
    create: XOR<publicationsCreateWithoutPublication_keywordsInput, publicationsUncheckedCreateWithoutPublication_keywordsInput>
    where?: publicationsWhereInput
  }

  export type publicationsUpdateToOneWithWhereWithoutPublication_keywordsInput = {
    where?: publicationsWhereInput
    data: XOR<publicationsUpdateWithoutPublication_keywordsInput, publicationsUncheckedUpdateWithoutPublication_keywordsInput>
  }

  export type publicationsUpdateWithoutPublication_keywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsUncheckedUpdateWithoutPublication_keywordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUncheckedUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type mesh_termsCreateWithoutPublication_mesh_termsInput = {
    id?: string
    term: string
    tree_number?: string | null
  }

  export type mesh_termsUncheckedCreateWithoutPublication_mesh_termsInput = {
    id?: string
    term: string
    tree_number?: string | null
  }

  export type mesh_termsCreateOrConnectWithoutPublication_mesh_termsInput = {
    where: mesh_termsWhereUniqueInput
    create: XOR<mesh_termsCreateWithoutPublication_mesh_termsInput, mesh_termsUncheckedCreateWithoutPublication_mesh_termsInput>
  }

  export type publicationsCreateWithoutPublication_mesh_termsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUncheckedCreateWithoutPublication_mesh_termsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesUncheckedCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsUncheckedCreateNestedManyWithoutPublicationsInput
    text_sections?: text_sectionsUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsCreateOrConnectWithoutPublication_mesh_termsInput = {
    where: publicationsWhereUniqueInput
    create: XOR<publicationsCreateWithoutPublication_mesh_termsInput, publicationsUncheckedCreateWithoutPublication_mesh_termsInput>
  }

  export type mesh_termsUpsertWithoutPublication_mesh_termsInput = {
    update: XOR<mesh_termsUpdateWithoutPublication_mesh_termsInput, mesh_termsUncheckedUpdateWithoutPublication_mesh_termsInput>
    create: XOR<mesh_termsCreateWithoutPublication_mesh_termsInput, mesh_termsUncheckedCreateWithoutPublication_mesh_termsInput>
    where?: mesh_termsWhereInput
  }

  export type mesh_termsUpdateToOneWithWhereWithoutPublication_mesh_termsInput = {
    where?: mesh_termsWhereInput
    data: XOR<mesh_termsUpdateWithoutPublication_mesh_termsInput, mesh_termsUncheckedUpdateWithoutPublication_mesh_termsInput>
  }

  export type mesh_termsUpdateWithoutPublication_mesh_termsInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    tree_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type mesh_termsUncheckedUpdateWithoutPublication_mesh_termsInput = {
    id?: StringFieldUpdateOperationsInput | string
    term?: StringFieldUpdateOperationsInput | string
    tree_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publicationsUpsertWithoutPublication_mesh_termsInput = {
    update: XOR<publicationsUpdateWithoutPublication_mesh_termsInput, publicationsUncheckedUpdateWithoutPublication_mesh_termsInput>
    create: XOR<publicationsCreateWithoutPublication_mesh_termsInput, publicationsUncheckedCreateWithoutPublication_mesh_termsInput>
    where?: publicationsWhereInput
  }

  export type publicationsUpdateToOneWithWhereWithoutPublication_mesh_termsInput = {
    where?: publicationsWhereInput
    data: XOR<publicationsUpdateWithoutPublication_mesh_termsInput, publicationsUncheckedUpdateWithoutPublication_mesh_termsInput>
  }

  export type publicationsUpdateWithoutPublication_mesh_termsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsUncheckedUpdateWithoutPublication_mesh_termsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUncheckedUpdateManyWithoutPublicationsNestedInput
    text_sections?: text_sectionsUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type publication_authorsCreateWithoutPublicationsInput = {
    author_order: number
    affiliation?: string | null
    authors: authorsCreateNestedOneWithoutPublication_authorsInput
  }

  export type publication_authorsUncheckedCreateWithoutPublicationsInput = {
    author_id: string
    author_order: number
    affiliation?: string | null
  }

  export type publication_authorsCreateOrConnectWithoutPublicationsInput = {
    where: publication_authorsWhereUniqueInput
    create: XOR<publication_authorsCreateWithoutPublicationsInput, publication_authorsUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_authorsCreateManyPublicationsInputEnvelope = {
    data: publication_authorsCreateManyPublicationsInput | publication_authorsCreateManyPublicationsInput[]
    skipDuplicates?: boolean
  }

  export type publication_entitiesCreateWithoutPublicationsInput = {
    id?: string
    confidence?: number | null
    context?: string | null
    entities: entitiesCreateNestedOneWithoutPublication_entitiesInput
  }

  export type publication_entitiesUncheckedCreateWithoutPublicationsInput = {
    id?: string
    entity_id: string
    confidence?: number | null
    context?: string | null
  }

  export type publication_entitiesCreateOrConnectWithoutPublicationsInput = {
    where: publication_entitiesWhereUniqueInput
    create: XOR<publication_entitiesCreateWithoutPublicationsInput, publication_entitiesUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_entitiesCreateManyPublicationsInputEnvelope = {
    data: publication_entitiesCreateManyPublicationsInput | publication_entitiesCreateManyPublicationsInput[]
    skipDuplicates?: boolean
  }

  export type publication_keywordsCreateWithoutPublicationsInput = {
    keywords: keywordsCreateNestedOneWithoutPublication_keywordsInput
  }

  export type publication_keywordsUncheckedCreateWithoutPublicationsInput = {
    keyword_id: string
  }

  export type publication_keywordsCreateOrConnectWithoutPublicationsInput = {
    where: publication_keywordsWhereUniqueInput
    create: XOR<publication_keywordsCreateWithoutPublicationsInput, publication_keywordsUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_keywordsCreateManyPublicationsInputEnvelope = {
    data: publication_keywordsCreateManyPublicationsInput | publication_keywordsCreateManyPublicationsInput[]
    skipDuplicates?: boolean
  }

  export type publication_mesh_termsCreateWithoutPublicationsInput = {
    is_major_topic: boolean
    mesh_terms: mesh_termsCreateNestedOneWithoutPublication_mesh_termsInput
  }

  export type publication_mesh_termsUncheckedCreateWithoutPublicationsInput = {
    mesh_term_id: string
    is_major_topic: boolean
  }

  export type publication_mesh_termsCreateOrConnectWithoutPublicationsInput = {
    where: publication_mesh_termsWhereUniqueInput
    create: XOR<publication_mesh_termsCreateWithoutPublicationsInput, publication_mesh_termsUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_mesh_termsCreateManyPublicationsInputEnvelope = {
    data: publication_mesh_termsCreateManyPublicationsInput | publication_mesh_termsCreateManyPublicationsInput[]
    skipDuplicates?: boolean
  }

  export type text_sectionsCreateWithoutPublicationsInput = {
    id?: string
    section_name: string
    content: string
    section_order?: number | null
  }

  export type text_sectionsUncheckedCreateWithoutPublicationsInput = {
    id?: string
    section_name: string
    content: string
    section_order?: number | null
  }

  export type text_sectionsCreateOrConnectWithoutPublicationsInput = {
    where: text_sectionsWhereUniqueInput
    create: XOR<text_sectionsCreateWithoutPublicationsInput, text_sectionsUncheckedCreateWithoutPublicationsInput>
  }

  export type text_sectionsCreateManyPublicationsInputEnvelope = {
    data: text_sectionsCreateManyPublicationsInput | text_sectionsCreateManyPublicationsInput[]
    skipDuplicates?: boolean
  }

  export type publication_authorsUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: publication_authorsWhereUniqueInput
    update: XOR<publication_authorsUpdateWithoutPublicationsInput, publication_authorsUncheckedUpdateWithoutPublicationsInput>
    create: XOR<publication_authorsCreateWithoutPublicationsInput, publication_authorsUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_authorsUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: publication_authorsWhereUniqueInput
    data: XOR<publication_authorsUpdateWithoutPublicationsInput, publication_authorsUncheckedUpdateWithoutPublicationsInput>
  }

  export type publication_authorsUpdateManyWithWhereWithoutPublicationsInput = {
    where: publication_authorsScalarWhereInput
    data: XOR<publication_authorsUpdateManyMutationInput, publication_authorsUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type publication_entitiesUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: publication_entitiesWhereUniqueInput
    update: XOR<publication_entitiesUpdateWithoutPublicationsInput, publication_entitiesUncheckedUpdateWithoutPublicationsInput>
    create: XOR<publication_entitiesCreateWithoutPublicationsInput, publication_entitiesUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_entitiesUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: publication_entitiesWhereUniqueInput
    data: XOR<publication_entitiesUpdateWithoutPublicationsInput, publication_entitiesUncheckedUpdateWithoutPublicationsInput>
  }

  export type publication_entitiesUpdateManyWithWhereWithoutPublicationsInput = {
    where: publication_entitiesScalarWhereInput
    data: XOR<publication_entitiesUpdateManyMutationInput, publication_entitiesUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type publication_keywordsUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: publication_keywordsWhereUniqueInput
    update: XOR<publication_keywordsUpdateWithoutPublicationsInput, publication_keywordsUncheckedUpdateWithoutPublicationsInput>
    create: XOR<publication_keywordsCreateWithoutPublicationsInput, publication_keywordsUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_keywordsUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: publication_keywordsWhereUniqueInput
    data: XOR<publication_keywordsUpdateWithoutPublicationsInput, publication_keywordsUncheckedUpdateWithoutPublicationsInput>
  }

  export type publication_keywordsUpdateManyWithWhereWithoutPublicationsInput = {
    where: publication_keywordsScalarWhereInput
    data: XOR<publication_keywordsUpdateManyMutationInput, publication_keywordsUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type publication_mesh_termsUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: publication_mesh_termsWhereUniqueInput
    update: XOR<publication_mesh_termsUpdateWithoutPublicationsInput, publication_mesh_termsUncheckedUpdateWithoutPublicationsInput>
    create: XOR<publication_mesh_termsCreateWithoutPublicationsInput, publication_mesh_termsUncheckedCreateWithoutPublicationsInput>
  }

  export type publication_mesh_termsUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: publication_mesh_termsWhereUniqueInput
    data: XOR<publication_mesh_termsUpdateWithoutPublicationsInput, publication_mesh_termsUncheckedUpdateWithoutPublicationsInput>
  }

  export type publication_mesh_termsUpdateManyWithWhereWithoutPublicationsInput = {
    where: publication_mesh_termsScalarWhereInput
    data: XOR<publication_mesh_termsUpdateManyMutationInput, publication_mesh_termsUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type text_sectionsUpsertWithWhereUniqueWithoutPublicationsInput = {
    where: text_sectionsWhereUniqueInput
    update: XOR<text_sectionsUpdateWithoutPublicationsInput, text_sectionsUncheckedUpdateWithoutPublicationsInput>
    create: XOR<text_sectionsCreateWithoutPublicationsInput, text_sectionsUncheckedCreateWithoutPublicationsInput>
  }

  export type text_sectionsUpdateWithWhereUniqueWithoutPublicationsInput = {
    where: text_sectionsWhereUniqueInput
    data: XOR<text_sectionsUpdateWithoutPublicationsInput, text_sectionsUncheckedUpdateWithoutPublicationsInput>
  }

  export type text_sectionsUpdateManyWithWhereWithoutPublicationsInput = {
    where: text_sectionsScalarWhereInput
    data: XOR<text_sectionsUpdateManyMutationInput, text_sectionsUncheckedUpdateManyWithoutPublicationsInput>
  }

  export type text_sectionsScalarWhereInput = {
    AND?: text_sectionsScalarWhereInput | text_sectionsScalarWhereInput[]
    OR?: text_sectionsScalarWhereInput[]
    NOT?: text_sectionsScalarWhereInput | text_sectionsScalarWhereInput[]
    id?: UuidFilter<"text_sections"> | string
    publication_id?: UuidFilter<"text_sections"> | string
    section_name?: StringFilter<"text_sections"> | string
    content?: StringFilter<"text_sections"> | string
    section_order?: IntNullableFilter<"text_sections"> | number | null
  }

  export type publicationsCreateWithoutText_sectionsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsUncheckedCreateWithoutText_sectionsInput = {
    id?: string
    pmcid: string
    pmid?: string | null
    doi?: string | null
    title: string
    abstract?: string | null
    publication_date?: Date | string | null
    journal?: string | null
    created_at: Date | string
    updated_at: Date | string
    abstract_generated?: string | null
    generation_type?: string | null
    key_findings?: string | null
    methodology?: string | null
    full_text_content?: string | null
    publication_authors?: publication_authorsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_entities?: publication_entitiesUncheckedCreateNestedManyWithoutPublicationsInput
    publication_keywords?: publication_keywordsUncheckedCreateNestedManyWithoutPublicationsInput
    publication_mesh_terms?: publication_mesh_termsUncheckedCreateNestedManyWithoutPublicationsInput
  }

  export type publicationsCreateOrConnectWithoutText_sectionsInput = {
    where: publicationsWhereUniqueInput
    create: XOR<publicationsCreateWithoutText_sectionsInput, publicationsUncheckedCreateWithoutText_sectionsInput>
  }

  export type publicationsUpsertWithoutText_sectionsInput = {
    update: XOR<publicationsUpdateWithoutText_sectionsInput, publicationsUncheckedUpdateWithoutText_sectionsInput>
    create: XOR<publicationsCreateWithoutText_sectionsInput, publicationsUncheckedCreateWithoutText_sectionsInput>
    where?: publicationsWhereInput
  }

  export type publicationsUpdateToOneWithWhereWithoutText_sectionsInput = {
    where?: publicationsWhereInput
    data: XOR<publicationsUpdateWithoutText_sectionsInput, publicationsUncheckedUpdateWithoutText_sectionsInput>
  }

  export type publicationsUpdateWithoutText_sectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUpdateManyWithoutPublicationsNestedInput
  }

  export type publicationsUncheckedUpdateWithoutText_sectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pmcid?: StringFieldUpdateOperationsInput | string
    pmid?: NullableStringFieldUpdateOperationsInput | string | null
    doi?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    abstract?: NullableStringFieldUpdateOperationsInput | string | null
    publication_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    journal?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    abstract_generated?: NullableStringFieldUpdateOperationsInput | string | null
    generation_type?: NullableStringFieldUpdateOperationsInput | string | null
    key_findings?: NullableStringFieldUpdateOperationsInput | string | null
    methodology?: NullableStringFieldUpdateOperationsInput | string | null
    full_text_content?: NullableStringFieldUpdateOperationsInput | string | null
    publication_authors?: publication_authorsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_entities?: publication_entitiesUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_keywords?: publication_keywordsUncheckedUpdateManyWithoutPublicationsNestedInput
    publication_mesh_terms?: publication_mesh_termsUncheckedUpdateManyWithoutPublicationsNestedInput
  }

  export type publication_authorsCreateManyAuthorsInput = {
    publication_id: string
    author_order: number
    affiliation?: string | null
  }

  export type publication_authorsUpdateWithoutAuthorsInput = {
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: publicationsUpdateOneRequiredWithoutPublication_authorsNestedInput
  }

  export type publication_authorsUncheckedUpdateWithoutAuthorsInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_authorsUncheckedUpdateManyWithoutAuthorsInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesCreateManyEntitiesInput = {
    id?: string
    publication_id: string
    confidence?: number | null
    context?: string | null
  }

  export type publication_entitiesUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    publications?: publicationsUpdateOneRequiredWithoutPublication_entitiesNestedInput
  }

  export type publication_entitiesUncheckedUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    publication_id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesUncheckedUpdateManyWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    publication_id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_keywordsCreateManyKeywordsInput = {
    publication_id: string
  }

  export type publication_keywordsUpdateWithoutKeywordsInput = {
    publications?: publicationsUpdateOneRequiredWithoutPublication_keywordsNestedInput
  }

  export type publication_keywordsUncheckedUpdateWithoutKeywordsInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
  }

  export type publication_keywordsUncheckedUpdateManyWithoutKeywordsInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
  }

  export type publication_mesh_termsCreateManyMesh_termsInput = {
    publication_id: string
    is_major_topic: boolean
  }

  export type publication_mesh_termsUpdateWithoutMesh_termsInput = {
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
    publications?: publicationsUpdateOneRequiredWithoutPublication_mesh_termsNestedInput
  }

  export type publication_mesh_termsUncheckedUpdateWithoutMesh_termsInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publication_mesh_termsUncheckedUpdateManyWithoutMesh_termsInput = {
    publication_id?: StringFieldUpdateOperationsInput | string
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publication_authorsCreateManyPublicationsInput = {
    author_id: string
    author_order: number
    affiliation?: string | null
  }

  export type publication_entitiesCreateManyPublicationsInput = {
    id?: string
    entity_id: string
    confidence?: number | null
    context?: string | null
  }

  export type publication_keywordsCreateManyPublicationsInput = {
    keyword_id: string
  }

  export type publication_mesh_termsCreateManyPublicationsInput = {
    mesh_term_id: string
    is_major_topic: boolean
  }

  export type text_sectionsCreateManyPublicationsInput = {
    id?: string
    section_name: string
    content: string
    section_order?: number | null
  }

  export type publication_authorsUpdateWithoutPublicationsInput = {
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
    authors?: authorsUpdateOneRequiredWithoutPublication_authorsNestedInput
  }

  export type publication_authorsUncheckedUpdateWithoutPublicationsInput = {
    author_id?: StringFieldUpdateOperationsInput | string
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_authorsUncheckedUpdateManyWithoutPublicationsInput = {
    author_id?: StringFieldUpdateOperationsInput | string
    author_order?: IntFieldUpdateOperationsInput | number
    affiliation?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    entities?: entitiesUpdateOneRequiredWithoutPublication_entitiesNestedInput
  }

  export type publication_entitiesUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_entitiesUncheckedUpdateManyWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entity_id?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type publication_keywordsUpdateWithoutPublicationsInput = {
    keywords?: keywordsUpdateOneRequiredWithoutPublication_keywordsNestedInput
  }

  export type publication_keywordsUncheckedUpdateWithoutPublicationsInput = {
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type publication_keywordsUncheckedUpdateManyWithoutPublicationsInput = {
    keyword_id?: StringFieldUpdateOperationsInput | string
  }

  export type publication_mesh_termsUpdateWithoutPublicationsInput = {
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
    mesh_terms?: mesh_termsUpdateOneRequiredWithoutPublication_mesh_termsNestedInput
  }

  export type publication_mesh_termsUncheckedUpdateWithoutPublicationsInput = {
    mesh_term_id?: StringFieldUpdateOperationsInput | string
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type publication_mesh_termsUncheckedUpdateManyWithoutPublicationsInput = {
    mesh_term_id?: StringFieldUpdateOperationsInput | string
    is_major_topic?: BoolFieldUpdateOperationsInput | boolean
  }

  export type text_sectionsUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type text_sectionsUncheckedUpdateWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type text_sectionsUncheckedUpdateManyWithoutPublicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    section_name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    section_order?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}